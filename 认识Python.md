# 	第一个 Python 程序

## 目标

- 第一个 *helloPython* 程序

- *Python 2 . x* 与 *3 . x* 版本简介

- 执行 *Python* 程序 的三种方式

  解释器 —— *Python / Python3*

  交互式 —— *ipython*

  集成开发环境 —— *PyCharm*

## 01.第一个 HelloPython 程序

### 1.1 Python源程序的基本概念

- Python 源程序就是**一个特殊格式的文本文件**，可以**使用任意文本编辑软件**做 *Python* 的开发
- Python程序的 **文件拓展名** 通常是 *.py*

*print*函数的作用，可以把“”内部的内容，输出到屏幕上

### 1.2 演练拓展--认识错误（BUG）

**关于错误**

- 编写的程序不能**正常执行**，或者**执行的结果不是我们期望的**
- **俗称** *BUG* ，是程序员在开发时非常常见的
- 在学习语言时，不仅要**学会语言的语法**，而且**要学会如何认识错误和解决错误的方法**

| *每一个程序员都是在不断地修改错误中成长的*

- *python 是一个格式非常严格的程序设计语言*
- *目前而言，大家记住每行代码前面都不要增加空格*

## 02.执行python程序的三种方式0

### 2.1解释器python/python3

python 的解释器

```
# 使用python 2.x 解释器
$ python xxx.py

# 使用 python 3.x 解释器
$ python3 xxx.py
```

**其他解释器**

**python 的解释器** 如今有多个语言的实现，包括：

- Cpython -- 官方版本的 C 语言实现
- Jython -- 可以运行在Java平台
- IronPython -- 可以运行在 .NET和Mono平台
- PyPy -- python实现的，支持JIT即时编译

### 2.2.交互式运行python程序

- 直接在终端中运行解释器，而不输入**python的代码**，会立即看到程序执行结果

#### 1）交互式运行python的优缺点

**优点**

- 适合于学习/验证python语法或者局部代码

**缺点**

- 代码不能保存
- 不适合运行太大的程序

#### 2）退出 官方的解释器

1>直接输入exit（）

```
>>> exit()
```

2>使用热键推出

在python解释器中，按热键 ctrl + d 可以推出解释器

#### 3）IPython

- IPython 中的“I”代表 **交互interactive**

**特点**

- IPython是一个python的**交互式shell**，比默认的 python shell 好用得多

  支持自动补全

  自动缩进

  支持 bash shell 命令

  内置了许多很有用的功能和函数

- IPython 是基于BSD开源的

### 2.3.python的IDE -- PyCharm

#### 1)集成开发环境（IDE）

集成开发环境 -- 集成了开发软件需要的所有工具，一般包括以下工具：

- 图形用户界面
- 代码编译器（支持 **代码补全/自动缩进**）
- 编译器/解释器
- 调试器（**断点/单步执行**）
- ······

#### 2）PyCharm 介绍

- PyCharm 是python 的一款非常优秀的集成开发环境

- PyCharm 除了具有一般IDE所具备功能外，还可以在 Windows、Linux、macOS 下使用

- PyCharm 适合开发大型项目

  一个项目通常会包含 **很多源文件**

  每个 **源文件** 的代码行数都是有限的，通常在几百行之内

  每个 **源文件** 各司其职，共同完成复杂的业务功能

#### 3）PyCharm 快速体验

![image-20210804135034079](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210804135034079.png)

- **文件导航区域**能够 **浏览/定位/打开** 项目文件

- **文件编辑区域** 能够 **编辑** 当前打开的文件

- **控制台区域** 能够：

  输出程序执行内容

  跟踪调试代码的执行

- 右上角的 **工具栏** 能够 **执行（SHIFT+F10）/调试（SHIFT+F9）代码**

# PyCharm的初始设置

## 目标

- 恢复PyCharm的初始设置
- 第一次启动PyCharm
- 新建一个PyCharm项目
- 设置PyCharm的字体显示
- PyCharm的升级以及其他

PyCharm 的官方网址是：https://www.jetbrains.com/pycharm/

## 01.恢复 PyCharm 的初始设置

PyCharm **的配置信息** 是保存在 **用户家目录下** 的 .PyCharmxxx.x 目录下的 xxx.x表示当前使用的 PyCharm 的版本号

恢复 PyCharm 的初始设置：

- 1.关闭正在运行的 PyCharm
- 2.在终端中执行以下终端命令，删除 PyCharm 的配置信息目录：

```
$ rm -r ~/.PyCharm2016.3
```

- 3.重新启动 PyCharm

## 02.新建/打开一个python项目

### 2.1 项目介绍

- 开发 **项目**就是开发一个 **专门解决一个复杂业务功能的软件**

- 通常没一个项目就具有一个 **独立专属的目录**，用于保存 **所以和项目相关的文件**

  一个项目通常会包含 **很多源文件**

### 2.2 打开python项目

- 直接点击open按钮，然后浏览之前保存 **python文件的目录**，既可以打开项目
- 打开后，会在目录下新建一个 .idea 的目录，拥于保存 **项目相关的信息**
- 第一次打开项目，需要耐心等待 PyCharm 对项目**进行初始设置**

### 2.3 新建项目

#### 1）命名规则

- 以后 **项目名** 前面都以 **数字编号**，随着知识点递增，编号递增

  例如：**01_python基础、02 _分支、03_循环...**

- 每个项目下的 **文件名** 都以 hm_xx_知识点 方式来命名

  其中 **xx** 是演练文件的序号

  - 注意

    1.命名文件名的是建议使用 **小写字母、数字** 和 **下划线**

    2.**文件名不能以数字开头**

## 03.设置PyCharm 的字体显示

## 04.PyCharm 的升级以及其他

|  *PyCharm 提供了对* ***学生和教师免费使用的版本***

- 教育版下载地址：https://www.jetbrains.com/pycharm-edu/download/#section=lonux
- 专业版下载地址：https://www.jetbrains.com/pycharm/download/#section=linux

### 4.1安装和启动步骤

- 1.执行以下终端命令，解压缩下载后的安装包

  ```
  $ tar -zxvf pyhcarm-professional-2017.1.3.tar.gz
  ```

  - 2.将解压缩后的目录移动到 /opt 目录下，可以方便其他用户使用

  |  /opt 目录用户存放给主机额外安装的软件

  ```
  $ sudo mv pycharm-2017.1.3/ /opt
  ```

  - 3.切换工作目录

  ```
  $ cd /opt/pycharm-2017.1.3/bin
  ```

  - 4.启动 PyCharm

```
$ ./pycharm.sh
```

### 4.2 卸载之前版本的PyCharm

1）程序卸载

- 1.删除解压缩目录

```
$ sudo rm -r /opt/pycharm-2016.3.1/
```

- 2.删除家目录下用于保存配置信息的隐藏目录

```
$ rm -r ~/.PyCharm2016.3/
```

***如果不在使用PyCharm还需要将*** */usr/share/applications/* ***下的*** *jetbrains-pycharm.desktop* ***删掉***

# 多文件项目的演练

- 开发项目就是开发一个专门解决一个复杂业务功能的软件

- 通常每一个项目就具有一个独立专属的目录，用于保存 **所有和项目相关的文件**

  一个项目通常会包含 **很多源文件**

## 目标

- 在项目中添加多个文件，并且设置文件的执行

## 多文件演练

**提示**

- 在 pycharm 中，要想让哪一个 python 程序能够执行，必须首先通过 **鼠标右键的方式执行一下**

# 注释

## 目标

- 注释的作用
- 单行注释（行注释）
- 多行注释（块注释）

## 01.注释的作用

|  *使用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性*

![image-20210805103010861](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210805103010861.png)

## 02.单行注释（行注释）

- 以 # 开头，# 右边的所有东西都被当作说明文字，而不是真正要执行的程序，只起到辅助说明作用
- 示例代码：

```
# 这是第一个单行注释
print("hello python")
```

|  *为了保证代码的可读性，# 后面建议先添加一个空格，让后在编写相应的说明文字*

**在代码后面增加单行注释**

- 在程序开发时，同样可以使用 # 在代码的后面（旁边）增加说明性的文字
- 但是，需要注意的是，**为了保证代码的可读性，注释和代码之间** 至少要有 **两个空格**
- 示例代码：

```
print("hello python") # 输出 `hello python`
```

## 03.多行注释（块注释）

- 如果希望编写的注释信息很多，一行无法显示，就可以使用多行注释
- 要在python程序中使用多行注释，可以用 **一对连续的三个引号**（单引号和双引号都可以）
- 示例代码：

```
"""
这是一个多行注释
在多行注释之间，可以写很多内容……
"""
print("hello python")
```

**什么时候需要使用注释？**

1. **注释不是越多越好**，对于一目了然的代码，不需要添加注释

2. 对于 **复杂的操作**，应该在操作开始前写上若干行注释

3. 对于 **不是一目了然的代码**，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码两个空格）

   *在一些正规的开发团队，通常会有* ***代码审核*** *的惯例，就是一个团队中彼此阅读对方的代码*

   *任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步*

# 算数运算符

**计算机**，顾名思义就是负责进行 **数学计算** 并且 **存储计算结果** 的电子设备

## 目标

- 算数运算符的基本使用

## 01.算数运算符

- 算数运算符是 **运算符的一种**
- 是完成基本的算术运算使用的符号，用来处理四则运算

| 运算符 | 描述   | 实例                                      |
| ------ | ------ | ----------------------------------------- |
| +      | 加     | 10 + 20 = 30                              |
| -      | 减     | 10 - 20 = -10                             |
| *      | 乘     | 10 * 20 = 200                             |
| /      | 除     | 10 / 20 = 0.5                             |
| //     | 取整数 | 返回除法的整数部分（商） 9 // 2 输出结果4 |
| %      | 取余数 | 返回除法的余数 9 % 2 = 1                  |
| **     | 幂     | 又称次方、乘方， 2 ** 3 = 8               |

- 在 python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果

```
In [1]: "-" * 50
Out[1]: '------------------------'
```

## 02.算数运算符的优先级

- 和数学中的运算符的优先级一致，在 python 中进行数学计算时，同样也是

  先乘除后加减

  同级运算符是 **从左至右** 计算

  可以使用 () 调整计算的优先级

- 以下表格的算数优先级由高到低顺序排列

| 运算符   | 描述                   |
| -------- | ---------------------- |
| **       | 幂(最高优先级)         |
| * / % // | 乘、除、取余数、取整数 |
| + -      | 加法、减法             |

# 程序执行原理

## 目标

- 计算机中的 **三大件**
- 程序执行的原理
- 程序的作用

## 01.计算机中的三大件

计算机中包含有较多的硬件，但是一个程序要运行，有 **是三个** 核心的硬件，分别是：

**1.cpu**

- 中央处理器，是一块超大规模的集成电路
- 负责 **处理数据/计算**

**2.内存**

- **临时** 存储数据（断电之后，数据会消失）
- 速度快
- 空间小
- 价格高

**3.硬盘**

- **永久** 存储数据
- 速度慢
- 空间大
- 价格便宜

![image-20210805124925992](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210805124925992.png)

## 02.程序执行的原理

![image-20210805135635490](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210805135635490.png)

1. 程序 **运行之前**，程序是 **保存在硬盘** 中的
2. 当要运行一个程序时
   - 操作系统会首先让 **cpu** 把程序复制到 **内存** 中
   - **cpu** 执行 **内存** 中的 **程序代码**

|  ***程序要执行，首先要被加载内存***

### 2.1 Python 程序执行原理

![image-20210805140158252](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210805140158252.png)

1. 操作系统会首先让 **cpu** 把 **Python 解释器** 的程序复制到 **内存**中
2. **Python 解释器** 根据语法规则，**从上向下** 让 **cpu** 翻译 **Python 解释器**
3. **cpu** 负责执行翻译完成的代码

**Python 的解释器有多大？**

- 执行以下终端命令可以查看 Python 解释器的大小

```
# 1. 确定解释器所在位置
$ which python

# 2. 查看 python 文件大小（只是一个软链接）
$ ls -lh /usr/bin/python

# 3. 查看具体文件大小
$ ls -lh /usr/bin/python2.7
```

*提示：建立* ***软链接*** *的目的，是为了方便使用者不用记住使用的解释器是* ***哪一个具体版本***

## 03.程序的作用

|  *程序就是* ***用来处理数据*** *的！*

### 3.1 思考QQ程序的启动过程

1. QQ在运行前，是保存在 **硬盘** 中的
2. 运行之后，QQ程序就会被加载到 **内存** 中了

![image-20210805142740459](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210805142740459.png)

### 3.2 思考QQ程序的登录过程

1. 读取用户输入的**QQ账号**
2. 读取用户输入的**QQ密码**
3. 将**QQ账号**和**QQ密码**发送给腾讯的服务器，等待服务器确认用户信息

**思考**

*QQ这个程序把**QQ账号**和**QQ密码**保存在哪里？*

答：保存在 **内存** 中，因为QQ程序自己就在内存中

*QQ这个程序是怎么保护用户的**QQ账号**和**QQ密码**的？*

答：1. 在内存中为**QQ账号**和**QQ密码**各自分配一块空间

- 在QQ程序结束之前，这两块空地是由QQ程序负责管理的，其他任何程序都不允许使用
- 在QQ自己完成之前，这两块空间始终都只负责保存**QQ账号**和**QQ密码**

2.使用一个 **别名** 标记**QQ账号**和**QQ密码**在内存中的位置

![image-20210805144245851](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210805144245851.png)

- *在程序内部，为**QQ账号**和**QQ密码**在内存中分配的空间就叫做 **变量***
- ***程序就是用来处理数据的，而变量就是用来存储数据的***

# 变量的基本使用

***程序用来处理数据，而变量是用来存储数据的***

## 目标

- 变量定义
- 变量的类型
- 变量的命名

## 01.变量定义

- 在Python中，每个变量 **在使用前都必须赋值**，变量 **赋值后** 该变量 **才会被创建**

- 等号（=）用来给变量赋值

  = 左边是一个变量名

  = 右边是存储在变量中的值

```
变量名 = 值
```

*变量定义之后，后续就可以直接使用了*

1）变量演练1--iPython

```
# 定义 qq_number 的变量来保存 qq 账号
In [1]: qq_number = "1234567"

# 输出 qq_number 中保存的内容
In [2]: qq_number
Out[2]: '1234567'

# 定义 qq_password 的变量来保存 qq 密码
In [3]: qq_password = "123"

# 输出 qq_password 中保存的内容
In [4]: qq_password
Out[4]: '123'
```

*使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用 print 函数*

- 变量名只有在第一次出现才是定义变量
- 变量名再次出现，不是定义变量，而是直接使用之前定义过的变量

在程序开发中，可以修改之前定义的变量中保存的值吗？

答：可以，变量中存储的值，就是可以变的

## 02.变量的类型

- 在内存中创建一个变量，会包括：
  1. 变量的名称
  2. 变量保存的数据
  3. 变量存储数据的类型
  4. 变量的地址（标识）

### 2.1变量类型

- 在 Python 中定义变量是 **不需要指定类型**（在其他很多高级语言中都需要）

- 数据类型可以分为**数字型**和**非数字型**

- 数字型

  int -- 整数

  float -- 浮点数（小数）

  bool -- 布尔（真假）

  - 真 Ture 非0数  --  非零即真
  - 假 False 0

  complex -- 复数型

  - 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题

- 非数字型

  字符串

  列表

  元组

  字典

*在Python 2.x 中，**整数** 根据保存数值的长度还分为:*

*int (整数)*

*long (长整数)*

- 在 iPython 中可以使用 type 函数可以查看一个变量的类型

```
In [1]: type(name)
```

### 2.2变量的输入

- 所谓 **输入**，就是 **用代码获取** 用户通过**键盘**输入的信息
- 在 Python 中，如果要获取用户在 **键盘** 上的输入信息，需要使用到 input 函数

#### 1）关于函数

- 一个 **提前准备好的功能**（别人或者自己写的代码），**可以直接使用**，而 **不用关心内部的细节**
- 目前已经学习过的函数

| 函数     | 说明                     |
| -------- | ------------------------ |
| print(x) | 将x输入到控制台          |
| type(x)  | 查看x的变量类型(iPython) |

#### 2）input 函数实现键盘输入

- 在 Python 中可以使用 input 函数从键盘等待用户的输入
- 用户输入的 **任何内容** Python 都认为是一个 **字符串**
- 语法如下：

```
字符串变量 = input("提示信息")
```

#### 3）类型转换函数

| 函数     | 说明                  |
| -------- | --------------------- |
| int(x)   | 将 x 转换为一个整数   |
| float(x) | 将 x 转换为一个浮点数 |

### 2.3变量的格式化

- 在 Python 中可以使用 print 函数将信息输出到控制台

- 如果希望输出文字信息的同时，**一起输出数据**，就需要使用到**格式化操作符**

- %被称为 **格式化操作符**，专门用于处理字符串中的格式

  包含%的字符串，被称为 **格式化字符串**

  %和不同的 **字符** 连用，**不同类型的数据** 需要使用 **不同的格式化字符**

| 格式化字符 | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| %s         | 字符串                                                       |
| %d         | 有符号十进制整数，%06d表示输出的整数显示位数，不足的地方使用0补全 |
| %f         | 浮点数，%.02f表示小数点后只显示两位                          |
| %%         | 输出%                                                        |

- 语法：

```
print("格式字符串"%变量1)
print("格式字符串"%(变量1，变量2. . .))
```

# 变量的命名

## 目标

- 标识符和关键字
- 变量的命名规则

## 0.1 标识符和关键字

1.1 标识符

*标识符就是程序员定义的 **变量名、函数名***

***名字*** *需要有 **见名知义** 的效果，如下图：*

![image-20210806115344540](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210806115344540.png)

- 标识符可以由 **字母、下划线** 和 **数字** 组成
- **不能以数字开头**
- **不能与关键字重名**

### 1.2 关键字

- **关键字** 就是在 python 内部已经使用的标识符
- **关键字** 具有特殊的功能和含义
- 开发者 **不允许定义和关键字相同的名字的标识符**

## 0.2 变量的命名规则

***命名规则** 可以被视为以一种 **惯例**，并无绝对与强制*

*目的是为了 **增加代码的识别和可读性***

python 中的 标识符 是区分大小写的

1. 在定义变量时，为了保证代码格式，= 的左右应该各保留一个空格

2. 在 python 中，如果 **变量名** 需要 两个 或多个单词 组成时，可以安照以下方式命名

   a. 每个单词都使用小写

   b. 单词与单词之间使用_下划线连接

#### 驼峰命名法

- 当 变量名 是由二个或多个单词组成时，还可以利用驼峰命名法来命名

- 小驼峰式命名法

  第一个单词以小写字母开始，后续单词的首字母大写

- 大驼峰式命名法

  每一个单词的首字母都采用大写字母

# 判断句

## 目标

- 开发中的应用场景
- if 语句体验
- if 语句进阶
- 综合应用

## 01. 开发中的应用场景

**程序中的判断**

![image-20210806140752122](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210806140752122.png)

**判断的定义**

- 如果 **条件满足**，才能做某件事

- 如果 **条件不满足**，就做另外一件事情，或者什么也不做

  ***判断语句*** *又被称为“分支语句”，正是因为有了判断，才让程序有了很多的分支*

## 02. if 语句体验

### 2.1 if 判断句基本语法

在 python 中，if 语法就是用来判断的，格式如下：

```
if 要判断的条件：
    条件成立时，要做的事情
    ……
```

*注意：代码的缩进为一个 tab 键，或者4个空格 -- **建议使用空格***

- *在 Python 开发中，Tab和空格键不要混用！*

| 运算符 | 描述                                             |
| ------ | ------------------------------------------------ |
| ==     | 检查两个操作数的值是否 **相等**                  |
| !=     | 检查两个操作数的值是否 **不相等**                |
| >      | 检查左操作数的值是否 **大于** 右操作数的值       |
| <      | 检查左操作数的值是否 **小于** 右操作数的值       |
| >=     | 检查左操作数的值是否 **大于或等于** 右操作数的值 |
| <=     | 检查左操作数的值是否 **小于或等于** 右操作数的值 |

### 2.2 else 处理条件不满足的情况

```
if 要判断的条件：
    条件成立时，要做的事件
    ……
else：
    条件不成立时，要做的事情
    ……
```

## 03. 逻辑运算

- 在程序开发中，通常 **在判断条件时**，会需要同时判断多个条件
- 只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 **逻辑运算**
- **逻辑运算符** 可以把 **多个条件** 按照 **逻辑** 进行 **连接**，变成 **更复杂的条件**
- Python 中的 **逻辑运算符** 包括：与 **and/或or/非not** 三种

### 3.1 and

```
条件1 and 条件2
```

- 与/并且
- 两个条件同时满足，返回 Ture
- 只要有一个不满做，就返回 False

### 3.2 or

```
条件1 or 条件2
```

- 或/或者
- 两个条件只要有一个满足，返回 Ture
- 两个条件都不满足，返回 False

### 3.3 not

```
not 条件
```

- 非/不是

## 04. if 语句进阶

### 4.1 elif

- 使用 else 可以处理 **条件不成立** 的情况
- 但是，如果希望 再增加一些条件，条件不同，**需要执行的代码也不同** 时，就可以使用 elif
- 语法格式如下：

```
if 条件1：
    条件1满足执行的代码
    ……
elif 条件2：
    条件2满足时，执行的代码
    ……
elif 条件3：
    条件3满足时，执行的代码
    ……
eles:
    以上条件都不满足时，执行的代码
    ……
```

**注意**

1. elif 和 else 都必须和 if 联合使用，而不能单独使用  

## 05.综合应用 -- 石头剪刀布

### 5.1随机数的处理

在 python 中，要使用随机数，首先需要导入 **随机数** 的 **模块** -- “工具包”

```
import random
```

- 导入模块后，可以直接在 ，**模块名称** 后面敲一个 . 然后嗯 Tab 键，会提示该模块中包含的所以函数
- random.randint(a,b) ，返回 [a,b] 之间的整数，包含 a 和 b

# 循环

## 目标

- 程序的三大流程
- while 循环基本使用
- break 和 continue
- while 循环嵌套

## 01. 程序的三大流程

- 在程序开发中，一共有三种流程方式：

  **顺序 -- 从上向下**，顺序执行代码

  **分支** -- 根据条件判断，决定执行代码的 **分支**

  **循环** -- 让 **特定代码 重复** 执行

![image-20210806163031719](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210806163031719.png)

## 02. while 循环基本使用

- 循环的作用就是让 **指定的代码** 重复的执行
- while 循环最常用的应用场景就是 **让执行的代码** 按照 **指定的次数重复** 执行

### 2.1 while 语句基本语法

```
初始条件设置 —— 通常是重复执行的 计数器while 条件(判断 计数器 是否达到 目标次数)    条件满足时，做的事情1    条件满足是，做的事情2    条件满足时，做的事情3    …(省略)…        处理条件(计数器 + 1)
```

**注意**

- while 语句以及缩进部分是一个 **完整的代码块**

*循环结束后，之前定义的计数器条件的数值是依旧存在的*

**死循环**

*由于程序员的原因，**忘记** 在循环内部 **修改循环的判断条件**，导致循环持续执行，程序无法终止！*

### 2.2 赋值运算符

- 在 python 中，使用 = 可以给变量赋值
- 在算数运算时，为了简化代码的编写，python还提供了一系列的与 **算术运算符** 对应的 **赋值运算符**
- 注意: 赋值运算符中间不能使用空格

| 运算符 | 描述                    | 实例                                 |
| ------ | ----------------------- | ------------------------------------ |
| =      | 简单的赋值运算符        | c = a + b 将 a + b的运算结果赋值为 c |
| +=     | 加法赋值运算符          | c += a 等效于 c = c + a              |
| -=     | 减法赋值运算符          | c -= a 等效于 c = c - a              |
| *=     | 乘法赋值运算符          | c *= a 等效于 c =  c * a             |
| /=     | 除法赋值运算符          | c /= a 等效于 c = c / a              |
| //=    | 取整数赋值运算符        | c // = a 等效于 c = c // a           |
| %=     | 取 模（余数）赋值运算符 | c %= a 等效于 c = c % a              |
| **=    | 幂赋值运算符            | c ******= 等效于 c = c****** a       |

2.3 Python 中的技数方法

常见的方法有两种，可以分别称为：

- 自然计数法（从 1 开始）-- 更符合人类的习惯

- 程序计数法（从 0 开始）-- 几乎所有的程序语言都选择从 0 开始计数

  因此，在编写程序时，应该尽量养成习惯：**除非需求的特殊要求，否则 循环 的计数都从0开始** 

### 2.4 循环计算

*在程序开发中，通常会遇到 **利用循环重复计算** 的需求*

遇到这种需求，可以：

1. 在 while 上方定义一个变量，用于 **存放最终计算结果**
2. 在循环内部，每次循环都用 **最新的计算结果,更新** 之前定义的变量

## 03. break 和 continue

*break 和 continue 是专门在循环中使用的关键字*

- break **某一条件满足时**，推出循环，不再执行后续重复的代码

- continue **某一条满足时**，不执行后续重复的代码

  *break 和 continue 只针对 **当前所在循环** 有效*

![image-20210809131130881](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210809131130881.png)

## 04. 循环嵌套

### 4.1 循环嵌套

- while 嵌套就是： while 里面还有 while

```
while 条件 1：
    条件满足时，做的事情1
    条件满足时，做的事情2
    条件满足是，做的事情3
    ...(省略)...
    
    while 条件 2:
        条件满足时,做的事情1
        条件满足时,做的事情2
        条件满足时,做的事情3
        ...(省略)...
        
        处理条件 2
    处理条件 1
```

知识点 :

- 在默认情况下,print 函数输出内容之后,会自动在内容末尾增加换行
- 如果不希望末尾增加换行,可以在 print 函数输出的内容后面增加, end=""
- 其中 " " 之间可以指定 print 函数输出内容之后,继续希望显示的内容
- 语法格式如下:

```
# 向控制台输出内容结束之后,不会换行
print("*", end="")

#单纯的换行
print("")
```

*end=" " 表示向控制台输出内容结束之后,不会换行*

**字符串中的转义字符**

- \t 在控制台输出一个 **制表符**,协助在输出文本时 **垂直方向** 保持对其
- \t 在控制台输出一个 **换行符**

**制表符** 的功能时在不使用表格的情况下在 **垂直方向** 按照对齐文本 

| 转义字符 | 描述       |
| -------- | ---------- |
| \\       | 反斜杠符号 |
| \\'      | 单引号     |
| \\"      | 双引号     |
| \n       | 换行       |
| \t       | 横向制表符 |
| \r       | 回车       |

# 函数基础

## 目标

- 函数的快速体验
- 函数的基本使用
- 函数的参数
- 函数的返回值
- 函数的嵌套调用
- 在模块中定义函数

## 01. 函数的快速体验

### 1.1快速体验

- 所谓**函数**,就是把 **具有独立功能的代码块** 组织为一个小模块,在需要调用的时候 **调用**
- 函数的使用包含两个步骤:
  1. 定义函数 -- **封装** 独立的功能
  2. 调用函数 -- 享受 **封装** 的成果

- **函数的作用**,在开发程序时,使用函数可以提高编写的效率以及代码的 **重用**

## 02. 函数的基本使用

### 2.1 函数的定义

定义函数的格式如下:

```
def 函数名():
    函数封装的代码
    ……
```

1. def 英文 define 的缩写
2. **函数名称** 应该能够表达 **函数封装代码** 的功能,方便后续的调用
3. **函数名称** 的命名应该 **符合 标识符的命名规则**
   - 可以由 **字母、下划线** 和 **数字** 组成
   - **不能以数字开头**
   - **不能与关键字重名**

### 2.2  PyCharm的调试工具

- F8 Step Over 可以单步执行代码,会把函数调用看作是一行代码直接执行
- F7 Step Into 可以单步执行代码,如果是函数,会进入函数内部

*注意: 因为 **函数体相对比较独立,函数定义的上方,**应该和其他代码(包括注释)保留 **两个空行***

## 03. 函数的参数

### 3.1 参数的作用

- **函数，**把 **具有独立功能的代码块** 组织为一个小模块，在需要的时候 **调用**
- **函数的参数，**增加函数的 **通用性，**针对 **相同的数据处理逻辑，**能够 **适应更多的数据**
  1. 在函数 **内部，**把参数当作 **变量** 使用，进行需要的数据处理
  2. 函数调用时，按照函数定义的 **参数顺序，** 把 **希望在函数内部处理的数据，通过参数** 传递

### 3.2 形参和实参

- **形参：定义** 函数时，小括号中的参数，是用来接收参数用的，在函数内部 **作为变量使用**
- **实参：调用** 函数时，小括号中的参数，是用来把数据传递到 **函数内部** 用的

## 04. 函数的返回值

- 在程序开发中，有时候，会希望 **一个函数执行结束后，告诉调用者一个结果，**以便调用者针对具体的结果做后续的处理

- **返回值** 是函数 **完成工作** 后，**最后** 给调用者的 **一个结果**

- 在函数中使用 return 关键字可以返回结果

- 调用函数一方，可以 **使用变量** 来 **接收** 函数的返回结果

  *注意：return 表示返回，后续的代码都不会被执行*

## 05. 函数的嵌套调用

- 一个函数里面 **又调用** 了 **另外一个函数，**这就是 **函数嵌套调用**

- 如果函数 test2 中，调用了另外一个函数 test1

  那么执行到调用 test1 函数时，会先把函数 test1中的任务都执行完

  才会回到 test2 中调用函数 test1 的位置，继续执行后续的代码

## 06. 使用模块中的函数

***模块是Python 程序架构的一个核心概念***

- **模块** 就好比是 **工具包，**要想使用这个工具包中的工具，就需要 **导入 import** 这个模块
- 每一个以拓展名 py 结尾的 Python 源代码文件都是一个 **模块**
- 在模块中定义的 **全局变量、函数** 都是模块能够供给给外界直接使用的工具

# 高级变量类型

## 目标

- 列表
- 元组
- 字典
- 字符串
- 公共方法
- 变量高级

## 01. 列表

### 1.1 列表的定义

- List (列表) 是 Python 中使用 **最频繁** 的数据类型，在其他语言中通常叫做 **数组**

- 专门用于存储 **一串 信息**

- 列表用[ ] 定义，**数据** 之间使用 ，分隔

- 列表的 **索引** 从 0 开始

  **索引** 就是数据在 **列表** 中的位置编号，**索引** 又可以被称为 **下标**

  *注意：从列表中取值时，如果 **超出索引范围，**程序会报错*

![image-20210810134851272](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210810134851272.png)

### 1.2  列表常用操作

```
In [1]: name_list
name_list.append   name_list.count    name_list.insert   name_list.reverse
name_list.clear    name_list.extend   name_list.pop      name_list.sort
name_list.copy     name_list.index    name_list.remove
```

| 序号 | 分类 | 关键字/函数/方法        | 说明                     |
| ---- | ---- | ----------------------- | ------------------------ |
| 1    | 增加 | 列表.insert(索引，数据) | 在指定位置插入数据       |
|      |      | 列表.append（数据）     | 在末尾追加数据           |
|      |      | 列表.extend（列表2）    | 将列表2 的数据追加到列表 |
| 2    | 修改 | 列表[索引] = 数据       | 修改指定索引的数据       |
| 3    | 删除 | del 列表[索引]          | 删除指定索引的数据       |
|      |      | 列表.remove[数据]       | 删除第一个出现的指定数据 |
|      |      | 列表.pop                | 删除末尾数据             |
|      |      | 列表.pop（索引）        | 删除指定索引数据         |
|      |      | 列表.clear              | 清空列表                 |
| 4    | 统计 | len（列表）             | 列表长度                 |
|      |      | 列表.count（数据）      | 数据在列表中出现的次数   |
| 5    | 排序 | 列表.sort()             | 升序顺序                 |
|      |      | 列表.sort(revers=Ture)  | 降序排序                 |
|      |      | 列表.reverse            | 逆转、反转               |

### 1.3 循环遍历

- **遍历** 就是 **从头到尾 依次** 从 **列表** 中获取数据

  在 **循环体内部** 针对 **每一个元素，**执行相同的操作

- 在 Python 中为了提高列表的遍历效率，专门提高的 **送代 iteration 遍历**

- 使用 for 就能够实现送代遍历

![image-20210810162048292](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210810162048292.png)

## 02. 元组

### 2.1 元组的定义

- Tuple （元组）与列表类似，不同之处在于元组的 **元素不能修改**

  **元组** 表示多个元素组成的序列

  **元组** 在 Python 开发中，有特定的应用场景

- 用于存储 **一串 信息，数据** 之间使用，分隔

- 元组用（）定义

- 元组的 **索引** 从 0 开始

  **索引** 就是数据在 **元组** 中的位置编号

```
info_touple = ("zhangsan",18,1.75)
```

**创建空元组**

```
touple = ()
```

**元组中 只包含一个元素 时，需要 在元素后面添加逗号**

### 2.2 循环遍历

- **取值** 就是从 **元组** 中获取存储在指定位置的数据
- **遍历** 就是 **从头到尾 依次** 从 **元组** 中获取数据、

- *在 Python 中，可以使用 for 循环遍历所有非数字型的变量：**列表、元组、字典** 以及 **字符串***
- *提示：在实际开发中，除非 **能够确定元组中的数据类型，**否则针对元组的循环遍历需求不是很多*

### 2.3 应用场景

1. 尽管可以使用 for in 遍历 **元组**
2. 但是在开发中，更多的应用场景是：
   - **函数的 参数 和 返回值，**一个函数可以接收 **任意多个参数，**或者 **一次放回多个数据**
   - **格式化字符串，**格式化字符串后面的（）本质上就是一个元组
   - **让列表不可以被修改，**以保护数据安全

元组和列表之间的转换

- 使用 list 函数可以把元组转换成列表
- 使用 tuple 函数可以把列表转换成元组

## 03. 字典

### 3.1 字典的定义

- dictionary （字典）是 **除列表以外** Python 之中 **最灵活** 的数据类型

- 字典同样可以用来 **存储多个数据**

  通常用于存储 **描述一个 物体 的相关信息**

- 和列表的区别

  **列表** 是 **有序** 的对象合集

  **字典** 是 **无序** 的对象合集

- 字典用 { } 定义

- 字典使用 **键值对** 存储数据，键值对之间使用 **，**分隔

  **键** key 是索引

  **值** value 是数据

  **键** 和 **值** 之间使用 ：分隔

  **键必须是唯一的**

  **值** 可以取任何数据类型，但 **键** 只能使用 **字符串、数字** 或 **元组**

```
xiaoming = {"name": "小明",
            "age": 18,
            "gender": Ture,
            "height": 1.75}
```

![image-20210811103043230](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811103043230.png)

### 3.2 字典的常用操作

```
In [1]: xiaoming
xiaoming.clear       xiaoming.items      xiaoming.setdefault
xiaoming.copy        xiaoming.keys       xiaoming.update
xiaoming.fromkeys    xiaoming.poo        xiaoming.values
xiaoming.get         xiaoming.popitem
```

### 3.3 循环遍历

- **遍历** 就是 **依次** 从 **字典** 中获取所有键值对

*提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多*

### 3.4 应用场景

- 尽管可以使用 for in 遍历 **字典**
- 但是在开发中，更多的应用场景是：
  1. 使用 **多个键值对，**存储 **描述一个 物体 的相关信息** -- 描述更复杂的数据信息
  2. 将 **多个字典** 放在 **一个列表** 中，再进行遍历，在循环遍历内部针对每一个字典进行 **相同的处理**

## 04. 字符串的定义

- **字符串** 就是 **一串字符串，**是编程语言中表示文本的数据类型

- 在 Python 中可以使用 **一对双引号 "** 或者 **一对单引号 '** 定义一个字符串

  虽然可以使用 \\" 或者 \\' 做字符串的转义，但是在实际开发中：

  - 如果字符串内部需要使用 " ，可以使用 ' 定义字符串
  - 如果字符串内部需要使用 ' ，可以使用 " 定义字符串

- 可以使用 **索引** 获取一个字符串中 **指定位置的字符，**索引计数从 **0** 开始

- 也可以使用 **for 循环遍历** 字符串中每一个字符

  *大多数编程语言都是用 " 来定义字符串*

![image-20210811150135623](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811150135623.png)

### 4.2 字符串的常用操作

![image-20210811152009600](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811152009600.png)

1）判断类型 - 9

![image-20210811152240116](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811152240116.png)

2）查找和替换 - 7

![image-20210811154756565](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811154756565.png)

3）大小写转换 - 5

![image-20210811160039646](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811160039646.png)

4）文本对齐 - 3

![image-20210811160139712](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811160139712.png)

5）去除空白符 - 3

![image-20210811160213456](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811160213456.png)

6）拆分和连接 - 5

![image-20210811162949006](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811162949006.png)

### 4.3 字符串的切片

- **切片** 方法适用于 **字符串、列表、元组**

  **切片** 使用 **索引值** 来限定范围，从一个大的 **字符串** 中 **切出** 小的 **字符串**

  **列表** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据

  **字典** 是一个 **无序** 的集合，是使用 **键值对** 保存数据

![image-20210811173537633](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210811173537633.png)

```
字符串[开始索引：结束索引：步长]
```

**注意：**

1. 指定的区间属于 **左闭右开** 型 [开始索引，结束索引] => 开始索引 >=范围 < 结束索引
   - **从 起始** 位开始，到 **结束 位的前一位** 结束（**不包含结束位本身**）
2. 从头开始，**开始索引 数字可以忽略，冒号不能省略**
3. 到末尾结束，**结束索引 数字可以省略，冒号不可以省略**
4. 步长默认为 1，如果连续切片，数字和冒号都可以省略

## 05. 公共方法

### 5.1 Python 内置函数

Python 包含了以下内置函数：

| 函数             | 描述                              | 备注                        |
| ---------------- | --------------------------------- | --------------------------- |
| len(item)        | 计算器中元素个数                  |                             |
| del(item)        | 删除变量                          | del 有两种方式              |
| max(item)        | 返回容器中元素最大值              | 如果是字典，只针对 key 比较 |
| min(item)        | 返回容器中元素最小值              | 如果是字典，只针对 key 比较 |
| cmp(item1,item2) | 比较两个值，-1 小于/0 相等/1 大于 | Python 3.x 取消了 cmp 函数  |

**注意**

- **字符串** 比较符合以下规则："0"<"A"<"a"

### 5.2 切片

| 描述 | Python 表达式      | 结果    | 支持的数据类型     |
| ---- | ------------------ | ------- | ------------------ |
| 切片 | "0123456789"[::-2] | "97531" | 字符串、列表、元组 |

- **切片** 使用 **索引值** 来限定范围，从一个大的 **字符串** 中 **切出** 小的 **字符串**
- **列表** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据
- **字典** 是一个 **无序** 的集合，是使用 **键值对** 保存数据

### 5.3 运算符

| 运算符       | Python 表达式     | 结果                     | 描述           | 支持的数据类型            |
| ------------ | ----------------- | ------------------------ | -------------- | ------------------------- |
| +            | [1,2] + [3,4]     | [1,2,3,4]                | 合并           | 字符串、列表、元组        |
| *            | ["Hi!"] * 4       | ['Hi!','Hi','Hi!','Hi!'] | 重复           | 字符串、列表、元组        |
| in           | 3 in (1,2,3)      | Ture                     | 元素是否存在   | 字符串、列表、元组、 字典 |
| not in       | 4 not in (1,2,3)  | Ture                     | 元素是否不存在 | 字符串、列表、元组、 字典 |
| > >= == < <= | (1,2,3) < (2,2,3) | Ture                     | 元素比较       | 字符串、列表、元组        |

注意

- in 在对 **字典** 操作时，判断的是 **字典的键**
- in 和 not in 被称为 成员运算符

**成员运算符**

成员运算符用于 **测试** 序列中是否包含指定的 **成员**

| 运算符 | 描述                                                  | 实例                         |
| ------ | ----------------------------------------------------- | ---------------------------- |
| in     | 如果在指定的序列中找到值返回 Ture,否则返回 False      | 3 in (1, 2, 3) 返回 Ture     |
| not in | 如果在指定的序列中没有找到值返回 Ture，否则返回 False | 3 not in (1, 2, 3)返回 False |

注意：在对 **字典** 操作时，判断的是 **字典的键**

### 5.4 完整的 for 循环语法

- 在 Python 中完整的 for 循环 的语法如下：

```
for 变量 in 集合：
    循环体代码
else:
    没有通过 break 推出循环，循环结束后，会执行的代码
```

# 综合应用 -- 名片管理系统

## 目标

综合应用已经学习过的知识点

- 变量
- 流程控制
- 函数
- 模块

开发 **名片管理系统**

## 系统需求

- 1. 程序启动，显示名片管理欢迎界面，并显示功能菜单

```
******************************
欢迎使用【名片管理系统】V1.0

1. 新建名片
2.显示全部
3.查询名片

0.退出系统
******************************
```

- 2. 用户用数字选择不同的功能
- 3. 根据功能选择，执行不同的功能
- 4. 用户名篇需要记录用户的 **姓名、电话、QQ、邮件**
- 5. 如果查询到指定的名片，用户可以选择 **修改** 或者 **删除** 名片

## 步骤

1. 搭建框架
2. 新增名片
3. 显示所有名片
4. 查询名片
5. 查询成功后修改名片、删除名片
6. 让 Python 程序能够直接运行

## 01. 搭建框架

### 目标

- 搭建名片管理系统 框架结构
  1. **准备文件，**确定文件名，保证能够 **在需要的位置** 编写代码
  2. 编写 **主运行循环，**实现基本的 **用户输入和判断**

### 1.1 文件准备

1. 新建 cards_main.py 保存 **所有名片功能函数**
   - 程序的入口
   - 每一次启动名片管理系统都通过 main 这个文件启动
2. 新建 cards_tools.py 保存 **所有名片功能函数**
   - 将对名片的 **新增、查询、修改、删除** 等功能封装在不同的函数中

### 1.2 编写主运行循环

**pass**

- pass 就是一个空语句，不做任何事情，一般用作占位语句
- 是为了保持结构的完整性

**无限循环**

- 在开发软件时，如果 **不希望程序执行后** 立即退出
- 可以在程序中增加一个 **无限循环**
- **由用户来决定** 推出程序的时机

**TODO 注释**

- 在 # 后跟上   TODO，用于标记需要去做的工作

```
# TODO（作者/邮件）显示系统菜单
```

## 02. 保存名片数据的结构

**程序就是用来处理数据的，而变量就是用来存储数据的**

- 使用 **字典** 记录 ，**每一张名片** 的详细信息
- 使用 **列表** 统一所有的 **名片字典**

![image-20210813150348806](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210813150348806.png)

### **定义名片列表变量**

- 在 cards_tools 文件的顶部增加一个 **列表变量**

```
# 所有名片记录的列表
card_list = []
```

**注意**

1. **所有名片相关操作，**都需要使用这个列表，所以应该 **定义在程序的顶部**
2. **程序刚运行时，没有数据，**所以是 **空列表**

## 03. LINUX 上的 Shebang 符号(#!)

- #! 这个符号叫做 Shebang 或者 Sha-bang
- Shebang 通常在 Unix 系统脚本的中 **第一行开头** 使用
- 指明 **执行这个脚本文件的** 的 **解释程序**

使用 Shebang 的步骤

- 1. 使用 which 查询 python3 解释器所在路径

```
$ which python3
```

- 2. 修改要运行的 **主 python文件，**在第一行增加以下内容

```
#! /user/bin/python3
```

- 3. 修改 **主 python 文件** 的文件权限，增加执行权限

```
$ chmod +x cards_main.py
```

- 4. 在需要时执行程序即可

```
./cards_main.py
```

# 变量的进阶（理解）

## 目标

- 变量的引用
- 可变和不可变类型
- 局部变量和全局变量

## 01. 变量的引用

- *变量 和 数据 都是保存在 **内存** 中的*
- *在 Python 中 **函数 的参数传递** 以及 **返回值** 都是靠 **引用** 传递的*

### 1.1 引用的概念

在 Python 中

- **变量** 和 **数据** 是分开存储的
- **数据** 保存在内存中的一个位置
- **变量** 中保存着数据在内存中的地址
- **变量** 中 **记录数据的地址，**就叫做 **引用**
- 使用 id( ) 函数可以查看变量中保存数据所在的 **内存地址**

*注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 **修改了数据的引用***

- *变量 **不再** 对之前的数据引用*
- *变量 **改为** 对新赋值的数据引用*

### 1.2 变量引用 的示例

在 Python 中，变量的名字类似于 **便签纸** 贴在 **数据** 上

- 定义一个整数变量 a，并且赋值为 1

![image-20210813183116344](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210813183116344.png)

- 将变量 a 赋值为 2

![image-20210813183205856](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210813183205856.png)

- 定义一个整数变量 b，并且加密和变量 a 的赋值给 b

![image-20210813183304112](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210813183304112.png)

*变量 b 是第2个贴在数字 2 上的标签*

### 1.3 函数的参数和返回值的传递

在 Python 中，函数的 **实参/返回值** 都是靠 **引用** 来传递的

## 02. 可变和不可变类型

- **不可变类型，**内存中的数据不允许被修改：

  数字类型 int , bool , float ,complex , long(2.x)

  字符串 str

  元组 tuple

- **可变类型，**内存中的数据可以被修改：

  列表 list

  字典 dict

```
a = 1
a = "hello"
a = [1, 2, 3]
a = [3, 2, 1]
```

![image-20210815113715457](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210815113715457.png)

*注意：字典的 key **只能使用不可变类型的数据***

**注意**

1. **可变类型**的数据变化，是通过 **方法** 来实现的
2. 如果给一个可变类型的变量，赋值了一个新的数据，**引用会修改**
   - 变量 **不再** 对之前的数据引用
   - 变量 **改为** 对新赋值的数据引用

### 哈希（hash）

- Python 中内置有一个名字叫做 hash(o) 的函数

  接收一个 **不可变类型** 的数据作为 **参数**

  **返回** 结果是一个 **整数**

- 哈希 是一种 **算法**，其作用就是提取数据的 **特征码（指纹）**

  **相同的内容** 得到 **相同的结果**

  **不同的内容** 得到 **不同的结果**

- 在 Python 中，设置字典的 **键值对** 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以便 **后续** 对字典的操作：**增、删、改、查**

  键值对的 key 必须是不可变类型

  键值对的 value 可以是任意类型的数据

## 03. 局部变量

- **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**

- **全局变量** 是在 **函数外部定义** 的变量（没有定义在某一个函数内），**所以函数** 内部 **都可以使用这个变量**

  提示：在其他的开发语言中，大多 **不推荐使用全局变量** -- 可变范围太大，导致程序不好维护！

### 3.1 局部变量

- **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**
- 函数执行结束后，**函数内部的局部变量，会被系统回收**
- 不同的函数，可以定义相同的名字的局部变量，但是各用个的不会产生影响

**局部变量的作用**

- 在函数内部使用，**临时** **保存函数内部需要使用的数据**

**局部变量的生命周期**

- 所谓 **生命周期** 就是变量从 **被创建** 到 **被系统回收** 的过程
- **局部变量** 在 **函数执行时** 才会被创建
- **函数执行结束后** 局部变量 **被系统回收**
- **局部变量在生命周期** 内，可以用来存储 **函数内部临时使用到的数据**

### 3.2 全局变量

- **全局变量** 是在 **函数外部定义** 的变量，所有函数内部都可以使用这个变量

**注意**：函数执行时，**需要处理变量时** 会：

1. **首先** 查找 **函数内部** 是否存在 **指定名称 的局部变量，如果有，直接使用**
2. 如果没有，查找 **函数外部** 是否存在 **指定名称 的全局变量，如果有，直接使用**
3. 如果还没有，程序报错！

#### 1）**函数不能直接修改 全局变量的引用**

- 在函数内部，可以通过全局变量的引用获取对应的数据

- 但是，**不允许直接修改全局变量的引用** -- 使用赋值改变全局变量的值

  *注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 -- 在函数内部不能直接修改全局变量的值*

#### 2）在函数内部修改全局变量的值

- 如果在函数中需要修改全局变量，需要使用 global 进行声明

#### 3）全局变量定义的位置

- 为了保证所有的函数都能够正确使用到全局变量，应该 **将全局变量定义其他函数的上方**

**注意**

- 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所有程序会报错！

**代码结构示意图如下**

![image-20210815141729764](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210815141729764.png)

#### 4）全局变量命名的建议

- 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：

  - 全局变量名前应该增加 g_ 或者 gl_ 的前缀

    *提示：具体的要求格式，各公司要求可能会有些差异*

# 函数参数和返回值

## 目标

- 函数参数和返回值的作用
- 函数的返回值 进阶
- 函数的参数 进阶
- 递归函数

## 01. 函数参数和返回值的作用

函数根据 **有没有参数** 以及 **有没有返回值，**可以 **相互组合，**一共有 **4 种** 组合形式

1. 无参数，无返回值
2. 无参数，有返回值
3. 有参数，无返回值
4. 有参数，有返回值

![image-20210815142906934](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210815142906934.png)

*定义函数时，**是否接收参数，或者是否返回结果，**是根据 **实际的功能需求** 来决定的！*

1. 如果函数 **内部处理的数据不确定，**就可以将外界的数据以参数传递到函数内部
2. 如果希望一个函数 **执行完成后，向外界汇报执行结果，**就可以增加函数的返回值

## 02. 函数的返回值 进阶

- 在出现开发中，有时候，会希望 **一个函数执行结束后，告诉调用者一个结果，**以便调用者针对具体的结果做后续处理
- **返回值** 是函数 **完成工作** 后，**最后** 给调用者的 **一个结果**
- 在函数中使用 return 关键字可以返回结果
- 调用函数一方，可以 **使用变量** 来 **接收** 函数的返回结果

## 03. 函数的参数 进阶

### 3.1 不可变和可变参数

在函数内部，参数使用 **赋值语句，**不会影响调用函数时传递的 **实参变量**

- 无论传递的参数时 **可变** 还是 **不可变**

  ​    只要 **针对参数** 使用 **赋值语句，**会在 **函数内部** 修改 **局部变量的引用，不会影响外部变量的引用**

- *如果传递的参数是 **可变类型**，在函数内部，使用 **方法** 修改了数据的内容，**同样会影响到外部数据***

- 在 Python 中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用

### 3.2 缺省参数

- 定义参数时，可以给 **某个参数** 指定一个**默认值**，具有默认值的参数就叫做 **缺省参数**
- 调用函数时，如果没有传入 **缺省参数** 的值，**则在函数内部使用定义函数时指定的参数默认值**
- 函数的缺省参数，**将常见的值设置为参数的缺省值，**从而 **简化函数的调用**
- 例如：对表排序法

```
gl_num_list = [6, 3, 9]

# 默认就是升序排序，因为这种应用需求更多
gl_num_list.sort()
print(gl_num_list)

# 只有当需要降序排序时，才需要传递 `reverse` 参数
gl_num_list.sort(reverse=Ture)
print(gl_num_list)
```

**指定函数的缺省参数**

- 在函数后使用赋值语句，可以指定参数的缺省值

  **提示**

  1. 缺省参数，需要使用 **最常见的值** 作为默认值！
  2. 如果一个参数的值 **不能确定**，则不应该设置默认值，具体的数值在调用函数时，由外界传递

**缺省参数的注意事项**

**1）缺省参数的定义位置**

- **必须保证 带有默认值的缺省参数 在参数列表末尾**

**2）调用带有多个缺省参数的函数**

- 在 **调用函数时，**如果有 **多个缺省参数，需要指定参数名，**这样解释器才能够知道参数的对应关系！

### 3.3 多值参数（知道）

定义支持多值参数的函数

- 有时可能需要 **一个函数** 能够处理的参数 **个数** 是不确定的，这个时候，就可以使用 **多值参数**

- Python 中有 **两种** 多值参数：

    参数名前增加 **一个** * 可以接收 **元组**

    参数名前增加 **两个** * 可以接收 **字典**

- 一般在给多值参数命名时，**习惯**使用以下两个名字

    `*args`-- 存放 **元组** 参数，前面有一个 `*`

     `**kwargs` -- 存放 **字典** 参数，前面有两个 `**`

- `args` 是 `arguments`的缩写，有变量的含义

- `kw`是 `keyword`的缩写，`keyword`可以记忆 **键值对参数**

#### 元组和字典的拆包（知道）

- 在调用带有多值参数的函数时，如果希望：
  1. 将一个 **元组变量**，直接传递给 `args`
  2. 将一个 **字典变量**，直接传递给 `kwargs`
- 就可以使用 **拆包，**简化参数的传递，**拆包** 的方法是：
  1. 在 **元组变量前，**增加 **一个 `*`**
  2. 在 **字典变量前，**增加 **两个 `*`**

## 04. 函数的递归

*函数调用自身的 **编程技巧** 称为递归*

### 4.1 递归函数的特点

**特点**

- **一个函数 内部 调用自己**

  ​    函数内部可以调用其他函数，当然在函数内部也可以调用自己

**代码特点**

1. 函数内部的 **代码** 是相同的，只是针对 **参数** 不同，**处理的结果不同**
2. 当 参数满足一个条件时，函数不再执行
   - **这个非常重要**，通常被称为递归的出口，否则 会出现死循环！

![image-20210815162052013](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210815162052013.png)

# 面向对象(OOP)基本概念

**面向对象编程 --** Object Oriented Programming 简写 OOP

## 目标

- 连接 **面向对象** 基本概念

## 01. 面向对象基本概念

- 我们之前学习的编程方式就是 **面向对象** 的
- **面向过程** 和 **面向对象，**是两种不同的 **编程方式**
- 对比 **面向过程** 的特点，可以更好地连接什么是 **面向对象**

### 1.1 过程和函数（科普）

- **过程** 是早期的一个编程概念
- **过程** 类似于函数，只能执行，但没有返回值
- **函数** 不仅能执行，还可以返回结果

### 1.2 面向过程 和 面向对象 基本概念

#### 1）面向过程 -- 怎么做？

1. 把完成某个需求的 `所有步骤` `从头到尾`逐步实现
2. 根据开发需求，将某些 **功能独立** 的代码 **封装** 成一个又一个 **函数**
3. 最后完成的代码，就是顺序地调用 **不同的函数**

**特点**

1. 注重 **步骤与过程**，不注重职责分工
2. 如果需求复杂，代码会变得很复杂
3. **开发复杂项目，没有固定的套路，开发难度很大！**

![image-20210815172817061](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210815172817061.png)

#### 2）面向对象 -- 谁来做？

*相比较函数，**面向对象** 是 **更大** 的 **封装**，根据 **职责** 在 **一个对象中 封装 多个方法***

1. 在完成某一个需求前，首先确定 **职责 -- 要做的事情（方法）**
2. 根据 **职责** 确定不同的 **对象**，在 **对象** 内部封装不同的 **方法**
3. 最后完成的代码，就是顺序地让 **不同的对象** 调用 **不同的方法**

**特点**

1. 注重 **对象和职责**，不同的对象承担不同 的职责
2. 更加适合应对复杂的需求变化，**是专门应对复杂项目开发，提供的固定套路**
3. **需求在面对过程基础上，在学习一些面向对象的语法**

![image-20210815173709966](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210815173709966.png)

# 类和对象

## 目标

- 类和对象的概率
- 类和对象的关系
- 类的设计

## 01. 类和对象的概念

**类** 和 **对象** 是 **面向对象编程的 两个 核心概念**

### 1.1 类

- **类** 是一群具有 **相同 特征** 或者 **行为** 的事物的一个统称，是抽象的，**不能直接使用**
  1. **特征** 被称为 **属性**
  2. **行为** 被称为 **方法**
- **类** 就相当于制造飞机时的**图纸，**是一个 **模块，**是 **负责创建对象的**

### 1.2 对象

- **对象** 是 **由类创建出来的一个具体存在，**可以直接使用

- 由 **哪一个类** 创建出来的 **对象**，就拥有在 **哪一个类** 中定义的：

  1. 属性
  2. 方法

- **对象** 就相当于用 **图纸 制造** 的飞机

  在程序开发中，应该 **现有类，再有对象**

## 02. 类和对象的关系

- **类是模块，对象** 是根据 **类** 这个模块创建出来的，应该 **现有类，再有对象**

- **类** 只有一个，而 **对象**可以有很多个

  ​    **不同的对象** 之间 **属性** 可能会各不相同

- **类** 中定义了什么 **属性和方法，对象** 中就有什么属性和方法，**不可能多，也不可能少**

## 03. 类的设计

在使用面相对象开发前，应该首先分析需求，确定以下，程序中需要包含哪些类

在程序开发中，要设计一个类，通常需要满足以下三个要素：

1. **类名** 这类事物的名字，**满足大驼峰命名法**
2. **属性** 这类事物具有什么样的特征
3. **方法** 这类事物具有什么样的行为

### 3.1 类名的确定

**名词提炼法** 分析 **整个业务流程**，出现的 **名词**，通常就是要找到的类

### 3.2 属性和方法的确定

- 对 **对象的特征描述，**通常可以定义成 **属性**
- **对象具有的行为**（动词），通常可以定义成 **方法**

*提示：需求中没有涉及的属性或者方法在设计类是，不需要考虑*

# 面向对象基础语法

## 目标

- `dir` 内置函数
- 定义简单的类（只包含方法）
- 方法中的 `self`参数
- 初始化方法
- 内置方法和属性

## 01. dir 内置函数（知道）

- 在 `Python`中 **对象几乎是无所不在的，**我们之间学习 的 **变量、数据、函数** 都是对象

在 `Python`中可以使用以下两个方法验证：

1. 在 **标识符/数据** 后输入一个 `.`,然后摁下` TAB`键，`iPython`会提示该对象能够调用的 **方法列表**
2. 使用内置函数`dir`传入 **标识符 / 数据**，可以查看对象内的 **所有属性及方法**

**提示** `__方法名__`格式的方法是`Python`提供的 **内置方法 / 属性，**

![image-20210815182534311](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210815182534311.png)

## 02. 定义简单的类

**面向对象** 是 **更大** 的 **封装**，在 **一个类中 封装 多个方法，**这样 **通过这个类创建出来的对象，就可以直接调用这些方法了！**

### 2.1 定义只包含方法的类

- 在`Python`中要定义一个只包含方法的类，语法格式如下：

```
class 类名
    def 方法(self,参数列表):
        pass
    def 方法2(self,参数列表)
        pass
```

- **方法** 的定义格式和之前学习过的**函数** 几乎一样
- 区别在于第一个参数必须是`self`

### 2.2 创建对象

- 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：

```
对象变量 = 类名()
```

**引用概率的强调**

- 在`Python`中使用类 **创建对象之后**，`tom`变量中 仍然记录的是 **对象在内存中的地址**

- 也就是`tom`变量 **引用** **了新建的猫对象**

- 使用`print`输出 **对象变量，**默认情况下，是能够输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 **在内存中的地址（十六进制表示）**

  *提示：在计算机中，通常使用 **十六进制** 表示 **内存地址***

  - **十进制** 和 **十六进制**都是用来表达数字的，只是表示的方式不一样
  - **十进制** 和 **十六进制** 的数字之间可以来回转换

- `%d`可以以 **10 进制** 输出数字

- `%x`可以以 **16 进制** 输出数字

## 03. 方法中的 self 参数

- 在`Python`中，要 **给对象设置属性，**非常的容易，**但是不推荐使用**

  ​     因为：对象属性的封装应该封装在类的内部

- 只需要在 **类的外部的代码** 中直接通过`.`设置一个属性即可

    注意：这种方式虽然简单，但是不推荐使用！

- 在 **类的外部，**通过`变量名.`访问对象的 **属性和方法**
- 在 **类封装的方法中，**通过`self.`访问对象的 **属性和方法**

## 04. 初始化方法

### 4.1 之前代码存在的问题 -- 在类的外部给对象增加属性

**提示**

- 在日常开发中，不推荐在 **类的外部** 给对象增加属性

  ​    如果 **在运行时，没有找到属性，程序会报错**

- 对象应该包含有哪些属性，应该 **封装在类的内部**

### 4.2 初始化方法

- 当  使用`类名()`创建对象时，会 **自动**执行以下操作：
  1. 为对象在内存中 **分配空间  --** 创建对象
  2. 为对象的属性 **设置初始值 --** 初始化方法`(init)`
- 这个 **初始化方法** 就是`_init_`方法，`_init_`是对象的**内置方法**

*`_init_`方法是 **专门** 用来定义一类 **具有哪些属性的方法！***

在`cat`中增加`_init_`方法，验证该方法在创建对象时会被自动调用

![image-20210816152740745](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210816152740745.png)

### 4.3 在初始化方法内部定义属性

- 在`_init_`方法内部使用`self.属性名 = 属性初始值`就可以 **定义属性**
- 定义属性之后，再使用`Cat`类创建的对象，都会应用该属性

![image-20210816153825266](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210816153825266.png)

### 4.4 改造初始化方法 -- 初始化的同时设置初始值

- 在开发中，如果希望在 **创建对象的同时，就设置对象的属性，**可以对`_init_`方法进行 **改造**
  1. 把希望设置的属性值，定义成`_init_`方法的参数
  2. 在方法内部使用`self.属性 = 形参`接收外部传递的参数
  3. 在创建对象时，使用`类名(属性1，属性2…)`调用

![image-20210816155836780](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210816155836780.png)

## 05. 内置方法和属性

| 序号 | 方法名        | 类型 | 作用                                        |
| ---- | ------------- | ---- | ------------------------------------------- |
| 01   | __ __del__ __ | 方法 | **对象被从内存中销毁**前，会被 **自动**调用 |
| 02   | __ __str__ __ | 方法 | 返回**对象的描述信息，**print 函数输出使用  |

### 5.1 __del__方法

- 在`Python`中
  1. 当使用`类名()`创建对象时，为对象 **分配完空间后，自动** 调用`_init_`方法
  2. 当一个 **对象被从内存中销毁** 前，会 **自动** 调用`__del__`方法
- **应用场景**
  1. `__init__`改造初始化方法，可以让创建对象更加灵活
  2. `__del__`如果希望在对象被销毁前，再做一些事情，可以考虑一下`__del__`方法
- **生命周期**
  1. 一个对象从调用`类名()`创建，生命周期开始
  2. 一个对象的`__del__`方法一旦被调用，生命周期结束
  3. 在对象的生命周期内，可以访问对象属性，或者让对象调用方法

### 5.2 __ __str__ __方法

- 在`Python`中，使用`print`输出 **对象变量**，默认情况下，会输出这个变量 **引用的对象** 是 **由哪一个类创建的对象，**以及 在内存中的地址（十六进制表示）
- 如果在开发中，希望使用`print`输出 **对象变量** 时，能够打印 **自定义的内容，**就可以利用`__str__`这个内置方法了

注意：`__str__`方法必须返回一个字符串

![image-20210816165700028](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210816165700028.png)

# 面向对象封装案例

## 目标

- 封装
- 小明爱跑步
- 存放家具

## 01. 封装

1. **封装** 是面向对象编程的一大特点
2. 面向对象编程的 **第一步** -- 将 **属性** 和 **方法 封装** 到一个抽象的 **类** 中
3. **外界** 使用 **类** 创建 **对象，**然后 **让对象调用方法**
4. **对象方法的细节** 都被 **封装** 在 **类的内部**

## 02. 小明爱跑步

**需求**

1. **小明 体重**`75.0`公斤
2. 小明每次 **跑步** 会减肥`0.5`公斤
3. 小明每次 **吃东西** 体重增加`1`公斤

![image-20210816170502401](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210816170502401.png)

*提示：在 **对象的方法内部，**是可以 **直接访问对象的属性** 的！* 

1. 在 **对象的方法内部，**是可以 **直接访问对象的属性** 的
2. **同一个类** 创建的 **多个对象** 之间，**属性** 互不干扰！

## 03. 摆放家具

1. **房子(House)** 有 **户型、总面积** 和 **家具名称列**
   - 新房子没有任何家具
2. 家具有 **名字** 和 **占地面积**，其中
   - 席梦思 占地 4 平米
   - 衣柜占地 2 平米
   - 餐桌占地 1.5 平米
3. 将以上三件 **家具 添加** 到 **房子** 中
4. 打印房子时，要求输出：**户型、总面积、剩余面积、家具名称列表 **

![image-20210817094715358](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210817094715358.png)

**剩余面积**

1. 在创建房子对象时，定义一个 **剩余面积的属性，初始值和总面积相等**
2. 当调用`add_item`方法，向房间 **添加家具** 时，让 **剩余面积 -= 家具面积**

# 面向对象封装案例 ||

1. **封装** 是面向对象编程的一大特点

2. 面向对象编程的 **第一步** -- 将 **属性** 和 **方法 封装** 到一个抽象的 **类** 中

3. **外界** 使用 **类** 创建 **对象，**然后 **让对象调用方法**

4. **对象方法的细节** 都被 **封装** 在 **类的内部**

      *一个对象的 **属性** **可以是另一个类创建的对象***

**定义没有初始值的属性**

在定义属性时，如果 **不知道设置什么初始值，**可以设置为`None`

- `None`**关键字** 表示 **什么都没有**
- 表示一个 **空对象，没有方法和属性，是一个特殊的常量**
- 可以将`None`赋值给任何一个变量

# 01. 身份运算符

身份运算符用于 **比较**  两个对象的 **内存地址** 是否一致 -- 是否 -- **是否是对同一个对象的引用**

- 在`Python`中针对`None`比较时，建议使用`is`判断

  | 运算符 | 描述                                      | 实例                            |
  | ------ | ----------------------------------------- | ------------------------------- |
  | is     | is 是判断两个标识符是不是引用同一个对象   | x is y, 类似id(x) == id(y)      |
  | is not | is not 是判断两个标识符是不是引用不同对象 | x is not y, 类似 id(a) != id(b) |

**is 与 == 区别：**

`is`用于判断 **两个变量 引用对向是否为同一个**

`==`用于判断 **引用变量的值** 是否相等

```
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> b is a
False
>>> b == 0
Ture
```

# 私有属性和私有方式

## 01. 应用场景及定义方式

**应用场景**

- 在实际开发中，**对象** 的 **某些属性或方法** 可能只希望 **在对象的内部使用，**而 **不希望在外部被访问到**
- **私有属性** 就是 **对象** 不希望公开的 **属性**
- **私有方法** 就是 **对象** 不希望公开的 **方法**

**定义方式**

- 在 定义属性或方法时，在 **属性名或者方法名**前增加 **两个下划线，**定义的就是 **私有** 属性或方法

## 02. 伪私有属性和私有方法

*提示：在日常开发中，**不要使用这种方式，访问对象的 私有属性 或 私有方法***

`Python`中，并没有 **真正意义** 的 **私有**



- 在给 **属性、方法** 命名时，实际是对 **名称** 做了一些特殊处理，使得外界无法访问到
- **处理方式**：在 **名称** 前面加上`_类名`=>`_类名__名称`

```
# 私有属性，外部不能直接访问到
print(xiaofang._Women__age)

# 私有方法，外部不能直接调用
xiaofang._Women__secret()
```

# 继承

## 目标

- 单继承
- 多继承

**面向对象三大特征**

1. **封装** 根据 **职责** 将 **属性** 和 **方法 封装** 到一个抽象的 **类** 中
2. **继承 实现代码的重用，**相同的代码不需要重复的编写
3. **多态** 不同的对象调用相同的方法，产生不同的执行结果，**增加代码的灵活度**

## 01. 单继承

### 1.1 继承的概念、语法和特点

继承的概念：**子类** 拥有 **父类** 的所有 **方法** 和 **属性**

![image-20210817161347103](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210817161347103.png)

#### 1）继承的方法

```
class 类名(父类名):
pass
```

- **子类** 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发
- **子类** 中应该根据 **职责**，封装 **子类特有的 属性和方法**

#### 2）专业术语

- `Dog`类是`Animal`类的子类，`Animal`类是`Dog`类的**父类**，`Dog`类从`Animal`类继承
- `Dog`类是`Animal`类的派生类，`Animal`类是`Dog`类的**基类**，`Dog`类从`Animal`类派生

#### 3）继承的传递性

- `C`类从`B`类继承，`B`类又从`A`类继承
- 那么`C`类具有`B`类和`A`的所有属性和方法

**子类** 拥有 **父类** 以及 **父类的父类** 中封装的所有 **属性** 和 **方法**

### 1.2 方法的重写

- **子类** 拥有 **父类 **的所有 **方法** 和 **属性**
- **子类** 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发

**应用场景**

- 当 **父类** 的方法实现不能满足子类需求时，可以对方法进行 **重写(override)**

![image-20210817170015587](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210817170015587.png)

**重写** 父类方法有两种情况：

1. **覆盖** 父类的方法
2. 对父类方法进行 **扩展**

#### 1）覆盖父类的方法

- 如果在开发中，**父类的方法实现** 和 **子类的方法实现，完全不同**

- 就可以使用 **覆盖** 的方式，**在子类中 重新编写** 父类的方法实现

  *具体的实现方式，就相当于在 **子类中** 定义了一个 **和父类同名的方法并且实现***

重写之后，在运行时，**只会调用** 子类中重写的方法，而不会调用 **父亲封装的方法**

#### 2）对父类的方法进行拓展

- 如果在开发中，**子类的方法实现** 中 **包含 父类的方法实现**

  ​    **父类原本封装的方法实现** 是 **子类方法的一部分**

- 就可以使用 **拓展** 的方式

  1. **在子类中 重写** 父类的方式
  2. 在需要的位置使用`super()父类方法.`来调用父类方法的执行
  3. 代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

**关于super**

- 在`Python`中`super`是一个 **特殊的类**
- `super()`就是使用`super`类创建出来的对象
- **最常** 使用的场景就是在 **重写父类方法时**，调用 **在父类中封装的方法实现**

### 1.3 父类的 私有属性 和 私有方法

1. **子类对象 不能** 在自己的方法内部，**直接** 访问 父类的 **私有属性** 或 **私有方法**
2. **子类对象** 可以通过 **父亲** 的 **共有方法 间接** 访问到 **私有属性** 或 **私有方法**
   - **私有属性、方法** 是对象的隐私，不对外公开，**外界** 以及 **子类** 都不能直接访问
   - **私有属性、方法** 通常用于做一些内部的事情

**示例**

![image-20210817182433315](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210817182433315.png)

- `B`的对象不能直接访问`__num2`属性
- `B`的对象不能在`demo`方法内访问`__num2`属性
- `B`的对象可以在`demo`方法内，调用父类的`test`方法
- 父类的`test`方法内部，能够访问`__num2`属性和`__test`方法

## 02. 多继承

**概率**

- **子类** 可以拥有 **多个父类**，并且具有 **所有父类** 的 **属性** 和 **方法**
- 例如：**孩子** 会继承自己 **父亲** 和 **母亲** 的 **特性**

![image-20210817190220713](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210817190220713.png)

**语法**

```
class 子类名(父类名1， 父类名2…)
    pass
```

### 2.1 多继承的使用注意事项

- **不同的父类** 中存在 **同名的方法，子类对象** 在调用方法时，会调用 **哪一个父类中**的方法呢？

  提示：**开发时，应该尽量避免这种容易产生混淆的情况！**-- 如果 **父类之间** 存在 **同名的属性或者方法，**应该 **尽量避免** 使用多继承

**Python 中的MRO -- 方法搜索顺序**

- `Python`中针对 **类** 提供了一个 **内置属性**`__mro__`可以查看 **方法** 搜索顺序
- **MRO** 是`methond resolution order`,主要用于 **在多继承时判断 方法、属性 的调用 路径**

```
Print(C.__mro)
```

**输出结果**

```
(<class '__main__.C'>, <class '__main__.B'>, <class 'object'>)
```

- 在搜索方法时，是按照`__mro__`的输出结果 **从左至右** 的顺序查找的
- 如果在当前类中 **找到方法，就直接执行，不再搜索**
- 如果 **没有找到，就查找下一个类** 中是否有应对的方法，**如果找到，就直接执行，不再搜索**
- 如果找到最后一个类，还没有找到方法，程序报错

### 2.2 新式类与旧式（经典）类

*`object`是`Python`为所有对象提供的 **基类，**提供有一些内置的属性和方法，可以使用`dir`函数查看*

- **新式类：**以 **object** 为基类的类，**推荐使用**

- **经典类：**不以**object** 为基类的类，**不推荐使用**

- 在`Python 3.x`中定义类时，如果没有指定父亲，会 **默认使用**`object`作为该类的 **基类 --** `Python 3.x`中定义的类都是 **新式类**

  **新式类** 和 **经典类** 在多继承时 -- **会影响到方法的搜索顺序**

今后在定义类时，**如果没有父类，建议统一继承自`object`**

```
class 类名(object):
    pass
```

# 多态

## 目标

1. **封装** 根据 **职责** 将 **属性** 和 **方法 封装** 到一个抽象的 **类** 中
   - 定义类的准则
2. **继承 实现代码的重用，**相同的代码不需要重复的编写
   - 设计类的技巧
   - 子类针对之间特有的需求，编写特定的代码
3. **多态** 不同的 **子类对象** 调用相同的 **父类方法**，产生不同的执行结果，**增加代码的灵活度**
   - **多态** 可以 **增加代码的灵活度**
   - 以 **继承** 和 **重写父类方法** 为前提
   - 是调用方法的技巧，**不会影响到类的内部设计**

![image-20210817200416409](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210817200416409.png)

## 01. 类的结构

### 1.1 术语 -- 实例

1. 使用面相对象开发，**第1步** 是设计 **类**
2. 使用 **类名()** 创建对象，**创建对象** 的动作有两步：
   - 1）在内存中为对象 **分配空间**
   - 2）调用初始化方法`__init__`为 **对象初始化**
3. 对象创建后，**内存** 中就有了一个对象的 **实实在在** 的存在 -- **实例**

![image-20210818112519299](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818112519299.png)

因此，通常也会把：

1. 创建出来的 **对象** 叫做 **类** 的 **实例**
2. 创建对象的 **动作** 叫做 **实例化**
3. **对象的属性** 叫做 **实例属性**

在程序执行时：

1. 对象各自拥有自己的 **实例属性**
2. 调用对象方法，可以通过`self.`
   - 访问自己的属性
   - 调用自己的方法

**结论**

- **每一个对象** 都有自己 **独立的内存空间，保存各自不同的属性**
- **多个对象的方法，在内存中只有一份，**在调用方法时，**需要把对象的引用** 传递到方法内部

### 1.2 类是一个特殊的对象

`*Python`中 **一切皆对象：***

- *`class AAA:`定义的类属于 **类对象***
- *`obj1 AAA()`属于 **实例对象***

- 在程序运行时，**类** 同样 **会被加载到内存**
- 在`Python`中，**类** 是一个特殊的对象 -- **类对象**
- 在程序运行时，**类对象** 在内存中 **只有一份，**使用 **一个类** 可以创造出 **很多个对象实例**
- 除了封装 **实例** 的 **属性** 和 **方法** 外，**类对象** 还可以拥有自己的 **属性** 和 **方法**
  1. **类属性**
  2. **类方法**
- 通过 **类名.** 的方式可以 **访问类的属性** 或者 **调用类的方法**

![image-20210818141327511](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818141327511.png)

## 02. 类属性和实例属性

### 2.1 概率和使用

- **类属性** 就是给 **类对象** 中定义的 **属性**
- 通常用来记录 **与这个类相关** 的特征
- **类属性 不会用于** 记录 **具体对象的特征**

**示例需求**

- 定义一个 **工具包**
- 每件工具都有自己的`name`
- **需求 -- **知道使用这个类，创建了多少个工具对象？

### 2.2 属性的获取机制

- 在`PYthon`中 **属性的获取** 存在一个 **向上查找机制**

![image-20210818143556990](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818143556990.png)

- 因此，要访问类属性有两种方式：
  1. **类名.类属性**
  2. **对象.类属性**（不推荐）

**注意**

- 如果使用`对象.类属性 = 值`赋值语句，只会 **给对象添加一个属性**，而不会影响到 **类属性的值**

## 03. 类方法和静态方法

### 3.1 类方法

- **类属性** 就是针对 **类对象** 定义的属性

  1. 使用 **赋值语句** 在`class`关键字下方可以定义 **类属性**
  2. **类属性** 用于记录 **与这个类相关** 的特征

- **类方法** 就是针对 **类对象** 定义的方法

  ​    在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的 **类方法**

**语法如下**

```
@classmethond
def 类方法名(cls):
    pass
```

- 类方法需要用 **修饰器**`@classmethond`来标识，**告诉显示器这是一个类方法**

- 类方法的 **第一个参数** 应该是`cls`

  1. 由 **哪一个** 调用的方法，方法内的`cls`就是 **哪一个类的引用**
  2. 这个参数和 **实例方法** 的第一个参数是`self`类似
  3. **提示** 使用其他名称也可以，不过习惯使用`cls`

- 通过 **类名.** 调用 **类方法，调用方法时，**不需要传递`cls`参数

- **在方法类别**

  1. 可以通过`cls.`**访问类的属性**
  2. 也可以通过`cls.`**调用其他的类方法**

  在类方法内部，可以直接使用`cls`访问 **类属性** 或者 **调用类方法**

### 3.2 静态方法

- 在开发时，如果需要在 **类** 中封装一个方法，这个方法：
  1. 既 **不需要** 访问 **实例属性** 或者调用 **实例方法**
  2. 也 **不需要** 访问 **类属性** 或者调用 **类方法**
- 这个时候，可以把这个方法封装成一个 **静态方法**

**语法如下**

```
@staticmethond
def 静态方法():
    pass
```

- **静态方法** 需要用 **修饰器**`@staticmethond`来标识，**告诉解释器这是一个静态方法**
- 通过 **类名.** 调用 **静态方法**

### 3.3 方法综合案例

**需求**

1. 设计一个`Game`类
2. 属性：
   - 定义一个 **类属性**`top_score`记录影响的 历史最高分
   - 定义一个 **实例属性**`player_name`记录 **当前游戏的玩家姓名**
3. 方法：
   - **静态方法**`show_help`显示游戏帮助信息
   - **类方法**`show_top_score`显示历史最高分
   - **实例方法**`start_game`开始当前玩家的游戏
4. 主程序步骤
   - 1）查看帮助信息
   - 2）查看历史最高分
   - 3）创建游戏对象，开始游戏

![image-20210818155338230](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818155338230.png)

**案例小结**

1. **案例方法** -- 方法内部需要访问 **实例属性**
   - **实例方法** 内部可以使用 **类名.** 访问类属性
2. **类方法** -- 方法内部 **只** 需要访问 **类属性**
3. **静态方法** -- 方法内部，不需要访问 **实例属性** 和 **类属性**

# 单例

## 目标

- 单例设计模式
- `__new__`方法
- Python 中的单例

## 01. 单例设计模式

- 设计模式
  1. **设计模式** 是 **前人工作的总结和提炼，**通常，被人们广泛流传的设计模式都是针对 **某一特定问题** 的成熟的解决方案
  2. 使用 **设计模式** 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性
- 单例设计模式
  1. 目的：-- 让 **类** 创建的对象，在系统中 **只有 唯一的一个实例**
  2. 每一次执行`类名()`返回的对象，**内存地址是相同的**

## 02. __ __new__ __方法

- 使用 **类名()** 创建对象时，`Python`的解释器 **首先** 会调用`__new__`方法为对象 **分配空间**

- `__new__`是一个由`object`基类提供的 **内置的静态方法**，主要作用有两个：

  1）在内存中为对象 **分配空间**

  2）**返回** 对象的引用

- `Python`的解释器获得对象的 **引用** 后，将引用作为 **第一个参数，**传递给`__init__`方法

  重写`__new__`方法 的代码非常固定！

- 重写`__new__`**方法一定要**`reture super().__new__(cls)`

- 否则 Python 的解释器 **得不到** 分配了空间的 **对象引用，就不会调用对象的初始化方法**

- 注意：`__new__`是一个静态方法，在调用时需要 **主动传递**`cls`参数

![image-20210818164545053](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818164545053.png)

## 03. Python 中的单例

- **单例** -- 让 **类** 创建的对象，在系统中 **只有 唯一的一个实例**
  1. 定义一个 **类属性**，初始值是`None`，用于记录 **单例对象的引用**
  2. 重写`__new__`方法
  3. 如果 **类属性**`is None`，调用父类方法分配空间，并在类属性中记录结果
  4. 返回 **类属性** 中记录的 **对象引用**

![image-20210818170243352](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818170243352.png)

**只执行一次初始化工作**

- 在每次使用`类名()`创建对象时，`Python`的解释器都会自动调用两个方法：
  1. `__new__`分配空间
  2. `__init__`对象初始化
  3. 在上一小节对`__new__`方法改造之后，每次都会得到 **第一次被创建对象的引用**
  4. 但是：**初始化方法还会被再次调用**

**需求**

- 让 **初始化动作** 只被 **执行一次**

解决办法

1. 定义一个类属性`init_flag`标记是否 **执行过初始化动作**，初始值为`False`
2.  在`__init__`方法中，判断`init_flag`，如果为`False`就执行初始化动作
3. 然后将`init_flag`设置为Ture
4. 这样，再次 **自动** 调用`__init__`方法时，**初始化动作就不会被再次执行** 了

# 异常

## 目标

- 异常的概念
- 捕获异常
- 异常的传递
- 自定义异常

## 01. 异常的概念

- 程序在运行时，如果`Python 解释器`**遇到** 一个错误，**会停止程序的执行，并且提示一些错误信息**，这就是 **异常**
- **程序停止执行并且提示错误信息** 这个动作，我们通常称之为：**抛出(raise)异常**

![image-20210818174747102](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818174747102.png)

*程序开发时，很难将 **所有的特殊情况** 都处理的面面俱到，通常 **异常捕获** 可以针对突发事件做集中的处理，从而保证程序的 **稳定性和健壮性***

## 02. 捕获异常

### 2.1简单的捕获异常语法

- 在程序开发中，如果 **对某些代码的执行不能确定是否正确吗，**可以增加`try(尝试)`来 **捕获异常**
- 捕获异常最简单的语法格式：

```
try:
    尝试执行的代码
except:
    出现错误的处理
```

- `try`**尝试**，下方编写要尝试代码，不确定是否能够正常执行的代码
- `except`**如果不是**，下方编写尝试失败的代码

### 2.2 错误类型捕获

- 在程序执行时，可能会遇到 **不同类型的异常**，并且需要 **针对不同类型的异常，做出不同的响应，**这个时候，就需要捕获错误类型了
- 语法如下：

```
try:
    # 尝试执行的代码
    pass
expect 错误类型1:
    # 针对错误类型1，对应的代码处理
    pass
expect (错误类型2, 错误类型3):
    # 针对错误类型2 和 3，对应的代码处理
    pass
expect Except as result:
    print("未知错误 %s" % result)
```

- 当`Python`解释器 **抛出异常** 时，**最后一行错误信息的第一个单词，就是错误类型**

**捕获未知错误**

- 在开发时，**要预判到所有可能出现的错误**，还是有一定难度的
- 如果希望程序 **无论出现任何错误，**都不会因为`Python`解释器 **抛出异常而被终止，**可以再增加一个`expect`

语法如下：

```
except Exception as result:
    print("未知错误 %s" % result)
```

### 	2.3 异常捕获完整语法

- 在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下：

  *提示：*

  - *有关完整语法的应用场景，在后续学习中，**结合实际的案例**会更好理解*
  - *现在先对这个语法结构有个印象*

![image-20210818201335246](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818201335246.png)

- `else`只有在没有异常时才会执行的代码
- `finally`无论是否有异常，都会执行的代码
- 之前一个演练的 **完整捕获异常** 的代码如下：

## 03. 异常的传递

- **异常的传递** -- 当 **函数/方法** 执行 **出现异常，**会 **将异常传递** 给 函数/方法 的 **调用一方**
- 如果 **传递到主程序**，仍然 **没有异常处理，**程序才会被终止

**提示：**

- 在开发中，可以在主函数中增加 **异常捕获**
- 而在主函数中的其他函数，只要出现异常，都会传递到主函数的 **异常捕获** 中
- 这样就不需要再代码中，增加大量的 **异常捕获，**能够保证代码的整洁

**需求**

1. 定义函数`demo1()`**提示用户输入一个整数并且返回**
2. 定义函数`demo2()`调用`demo1()`
3. 在主程序中调用`demo2()`

![image-20210818204109463](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818204109463.png)

## 04. 抛出 raise 异常

### 4.1应用场景

- 在开发中，除了 **代码执行出错**`Python`解释器会 **抛出** 异常之外
- 还可以根据 **应用程序 特有的业务需求 主动抛出异常**

示例

- 提示用户 输入密码，如果 长度少于8，抛出 **异常**

![image-20210818205303837](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210818205303837.png)

**注意**

- 当前函数 **只负责** 提示用户输入密码，如果 **密码长度不正确，需要其他的函数进行额外处理**
- 因此可以 **抛出异常**，由其他需要处理的函数 **捕获异常**

### 4.2 抛出异常

- `Python`中提供了一个`Exception`异常类
- 在开发时，如果满足 **特定业务需求时**，希望 **抛出异常，**可以：
  1. 创建一个`Exception`的 **对象**
  2. 使用`raise`**关键字** 抛出 **异常对象**

# 模块基础

## 目标

- 模块
- 包
- 模块的制作

## 01.模块

### 1.1模块的概念

***模块是 Python 程序架构的一个核心概念***

- 每一个以拓展包名`py`结尾的`Python`原代码文件都是一个 **模块**
- **模块名** 同样也是一个 **标识符**，需要符号标识符发命名规则
- 在模块中定义的 **全局变量、函数、类** 都是提供给外界直接使用的 **工具**
- **模块** 就好比是 **工具包**，要使用这个工具包中的工具，就需要先 **导入** 这个模块

### 1.2 模块的两种导入方式

#### 1）import 导入

```
import 模块名1，模块名2
```

提示：在导入模块时，每个导入应该独占一行

```
import 模块名1
import 模块名2
```

- **导入之后**
  1. 通过`模块名.`使用 **模块提供的工具 -- 全局变量、函数、类**

**使用 as 指定模块的别名**

​       **如果模块的名字太长，**可以使用`as`指定模块的名称，以便在代码中的使用

```
import 模块名1 as 模块别名
```

*注意：**模块别名** 应该符号 **大驼峰命名法***

#### 2）from...import 导入

- 如果希望 **从每一个模块** 中，导入 **部分** 工具，就可以使用`from...import`的方式
- `import 模块名`是 **一次性** 吧模块中 **所有工具全部导入，**并且通过 **模块名/别名** 访问

```
# 从 模块 导入 某一个工具
from 模块名1 import 工具名
```

- 导入之后
  1. **不需要** 通过 `模块名.`
  2. 可以直接使用 **模块提供的工具 -- 全局变量、函数、类**

**注意**

*如果 **两个模块，**存在 **同名的函数，**那么 **后导入模块的函数，**会 **覆盖掉先导入的函数***

- 开发时`import`代码应该统一写在 **代码的顶部**，更容易及时发现冲突
- 一旦发现冲突，可以使用`as`关键字 **给其中一个工具起一个别名**

from…import *（知道）

```
# 从 模块 导入 所有工具
from 模块名1 import *
```

**注意**

*这种方式不推荐使用，因为函数重名并没有任何的提示，出现问题不好排除*

### 1.3 模块的搜索顺序

`Python`的解释器在 **导入模块** 时，会：

1. 搜索 **当前目录** 指定模块名的文件，**如果有就直接导入**

2. 如果没有，再搜索 **系统目录**

   在开发时，给文件起名，不要和 **系统的模块文件 重名**

`Python`中每一个模块都有一个内置属性`__file__`可以 **查看模块** 的 **完整路径**

```
import random

# 生成一个 0 ~ 10 的数字
rand = random，randint(0, 10)

print(rand)
```

*注意：如果当前目录下，存在一个`random.py`的文件，程序就无法正常执行了！*

- 这个时候，`Python`的解释器会 **加载当前目录** 下的`random.py`而不会加载 **系统的** `random`模块

### 1.4 原则 -- 每一个文件都应该是可以被导入的

- 一个 **独立的`Python`文件** 就是一个 **模块**
- 在导入文件时，文件中 **所有没有任何缩进的代码** 都会被执行一遍！

**实际开发场景**

- 在实际开发中，每一个模块都是独立开发的，大多都有专人负责

- **开发人员** 通常会在 **模块下方 增加一些测试代码**

     仅在模块内使用  ，而被导入到其他文件中不需要执行

### __ __name__ __属性

- `__name__`属性可以做到，测试模块的代码 **只在测试情况下被运行**，而在 **被导入时不会被执行！**

- `__name___`是`Python`的一个内置属性，记录着一个 **字符串**
- 如果 **是被其他文件导入的，**`__name__`就是 **模块名**
- 如果 **是当前执行的程序**`__name__`是`__main__`

## 02. 包

###  概念

- **包** 是一个 **包含多个模块** 的 **特殊目录**
- 目录下有一个 **特殊的文件**`__init__.py`
- 包含的 **命名方式** 和变量名一致，**小写字母 +**`_`

**好处**

- 使用`import 包含`可以一次性导入 **包** 中 **所有的模块**

**__ init __.py**

- 要在外界使用 **包** 中的模块，需要在`__init__.py`中指定 **对外界提供的模块列表**

```
从 当前目录 导入 模块列表
from . import send_message
from . import receive_message
```

## 03. 发布模块（知道）

- 如果希望直接开发的模块，**分享** 给其他人，可以按照以下步骤操作

### 3.1 制作发布压缩包步骤

#### 1）创建 setup.py

- `setup.py`的文件

![image-20210820145933654](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210820145933654.png)

有关字典参数的详细信息，可以参阅官方网站：

https://docs.python.org/2/distutils/apiref.html

#### 2）构建模块

```
$ python3 setup.py build
```

3）生成发布压缩包

```
$ python3 setup,py sdist
```

### 3.2 安装模块

```
$ tar -zxvf hm_message-1.0.tar.gz

$ sudo python3 setup.py install
```

**卸载模块**

直接从安装目录下，吧安装模块的 **目录** 删除就可以

```
$ cd /usr/local/lib/python3.5/dist-packages/
$ sudo rm -r hm_message*
```

### 3.3 pip 安装第三方模块

- **第三方模块** 通常是指由 **知名的第三方团队 开发的** 并且被 **程序员广泛使用** 的`Python`包/模块

  ​      例如`pygame`就是一套非常成熟的 **游戏开发模块**

- `pip`是一个现代的，通用的`Python`包管理工具
- 提供了对`Python`包的查找、下载、安装、卸载等功能

安装和卸载命令如下：

![image-20210820152245399](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210820152245399.png)

**在 Mac 下安装 iPython**

```
$ sudo pip install iPython
```

**在 Linux 下安装 iPython**

```
$ sudo apt install iPython
$ sudo apt install iPthon3
```

# 文件

## 目标

- 文件的概率
- 文件的基本操作
- 文件/文件夹的常用操作
- 文本文件的编码方式

## 01. 文件的概念

### 1.1 文件的概念和作用

- 计算机的 **文件**，就是存储在某种 **长期存储设备** 上的一段 **数据**
- 长期存储设备包括：硬盘、U盘、移动硬盘、光盘…

**文件的作用**

将数据长期保存下来，在需要的时候使用

### 1.2 文件的存储方式

- 在计算机中，文件是以 **二进制** 的方式保存在磁盘上

**文本文件和二进制文件**

- 文本文件
  1. 可以使用 **文本编辑软件** 查看
  2. 本质上还是二进制文件
  3. 例如：python的源文件
- 二进制文件
  1. 保存的内容 不是给人直接阅读的，而是 **提供给其他软件使用的**
  2. 二进制文件不能使用 **文本编辑软件** 查看

## 02. 文件的基本操作

### 2.1 操作文件的套路

在 **计算机** 中要操作文件的套路非常固定，一共包含**三个步骤：**

1. 打开文件
2. 读、写文件
   - **读** 将文件内容读入内存
   - **写** 将内存内容写入文件
3. 关闭文件

### 2.2 操作文件的函数/方法

- 在`Python`中要操作文件需要记住 1 个函数和 3 个方法

| 序号 | 函数/方法 | 说明                           |
| ---- | --------- | ------------------------------ |
| 01   | open      | 打开文件，并且返回文件操作对象 |
| 02   | read      | 将文件内容读取到内存           |
| 03   | write     | 将指定内容写入文件             |
| 04   | close     | 关闭文件                       |

- `open`函数负责打开文件，并且返回文件对象
- `read`/`write`/`close`三个方法都需要通过 **文件对象** 来调动

### 2.3 read 方法 -- 读取文件

- `close`方法负责 **关闭文件**

如果 **忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问**

- **注意：**方法执行后，会把 **文件指针** 移动到 **文件的末尾**

```
# 1. 打开 - 文件名需要注意大小写
file = open("README")

# 2. 读取
text = file.read()
print(text)

# 3. 关闭
file.close()
```

**提示**

- 在开发中，通常会先编写 **打开** 和 **关闭** 的代码，再编写中间针对文件的 读/写 操作！

#### 文件指针（知道）

- **文件指针** 标记 **从哪个位置开始读取数据**

- **第一次打开** 文件时，通常 **文件指针会指向文件的开始位置**

- 当执行了`read`方法后，**文件指针** 会移动到 **读取内容的末尾**

     默认情况下会移动到 **文件末尾**

- 如果执行了一次`read`方法，读取了所有内容，那么再次调用`read`方法，还能够得到内容吗？

**答案**

- 不能
- 第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容

### 2.4 打开文件的方式

- `open`函数默认以 **只读方式** 打开文件，并且返回文件对象

语法如下：

```
f = open("文件名"，"访问方式")
```

![image-20210820162542593](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210820162542593.png)

**提示**

- 频繁的移动文件指针，**会影响文件的读写效率，**开发中更多的时候会以 **只读、只写** 的方式来操作文件

### 2.5 按行读取文件内容

- `read`方法默认会把文件的 **所有内容 一次性读取到内存**
- 如果文件太大，对内存的占用会非常严重

#### readline 方法

- `readline`方法可以一次读取一行内容
- 方法执行后，会把 **文件指针** 移动下一行，准备再次读取

**读取大文件的正确姿势**

![image-20210820165910324](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210820165910324.png)

2.6 文件读写案例 -- 复制文件

目标

用代码的方式，来实现文件复制过程

![image-20210820171002552](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210820171002552.png)

**小文件复制**

- 打开一个已有文件，读取完整内容，并写入到另一个文件

![image-20210820171931707](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210820171931707.png)

**大文件复制**

- 打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件

## 03.  文件/目录的常用管理操作

- 在 **终端/文件浏览器**、中可以执行常规的 **文件/目录** 管理操作，例如：

    创建、重命名、删除、改变路径、查看目录内容、……

- 在`Python`中，如果希望通过程序实现上述功能，需要导入`os`模块

### 文件操作

| 序号 | 方法名 | 说明       | 示例                            |
| ---- | ------ | ---------- | ------------------------------- |
| 01   | rename | 重命名文件 | os.rename(源文件名，目标文件名) |
| 02   | remove | 删除文件   | os.remove(文件名)               |

目标操作

| 序号 | 方法名     | 说明           | 示例                    |
| ---- | ---------- | -------------- | ----------------------- |
| 01   | listdir    | 目录列表       | os.listdir(目录名)      |
| 02   | mkdir      | 创建目录       | os.mkdir(目录名)        |
| 03   | rmdir      | 删除目录       | os.rmdir(目录名)        |
| 04   | getcwd     | 获取当前目录   | os.getcwd()             |
| 05   | chdir      | 修改工作目录   | os.chdir(目标目录)      |
| 06   | path.isdir | 判断是否是文件 | os.path.isdir(文件路径) |

*提示：文件或者目录操作都支持 **相对路径** 和 **绝对路径***

## 04. 文本文件的编码格式（科普）

- 文本文件存储的内容是基于 **字符编码** 的文件，常见的编码有`ASCII`编码，`UNICODE`编码等

  *Python 2.x 默认使用`ASCII`编码*

  *Python 3,x 默认使用`UTF-8`编码*

### 4.1 ASCII 编码和 UNICODE 编码

#### ASCII 编码

- 计算机中只有`256`个`ASCII`字符

- 一个`ASCII`在内存中占用 **1 个字节** 的空间

  ​    `8`个`0/1`的排列组合方式一共有`256`种，也就是`2 ** 8`

![image-20210820175851500](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210820175851500.png)

#### UTF-8 编码格式

- 计算机中使用**1~6 个字节**来表示一个`UTF-8`字符，涵盖了 **地球上几乎所有地区的文字**
- 大多数汉字会使用 **3个字节** 表示
- `UTF-8`是`UNICODE`编码的一种编码格式

# eval 函数

`eval()`函数十分强大 -- **将字符串** 当成 **有效的表达式** 来 求值 并 **返回计算结果**

![image-20210820180732863](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210820180732863.png)

#### 案例 - 计算器

**需求**

1. 提示用户输入一个 **加减乘除混合运算**
2. 返回计算结果

![image-20210820181959362](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210820181959362.png)

#### 不要滥用 eval

*在开发时千万不要使用`eval`直接转换`input`的结果*

```
__import__('os').system('ls')
```

- **等价代码**

```
import os

os.system("终端命令")
```

- 执行成功，返回 0
- 执行失败，返回错误信息

# 项目实战 -- 飞机大战

## 目标

- 强化 **面向对象** 程序设计
- 体验使用`pygame`模块设计

## 实战步骤

1. `pygame`快速体验
2. **飞机大战** 实战

## 确认模块 -- pygame

- `pygame`就是一个 Python 模块，专为电子游戏设计

- 官方网站：https://www.pygame.org/

  ​    **提示：**要学习第三方模块，通常最好的参考资料就在官方网站

| 网站栏目       | 内容                                          |
| -------------- | --------------------------------------------- |
| GettingStarted | 在各平台安装模块的说明                        |
| Docs           | pygame 模块所有 **类** 和 **子类** 的参考手册 |

**安装 pygame**

```
$ sudo pip3 install pygame
```

**验证安装**

```
$ python3 -m-pygame.examples.aliens
```

# pygame 快速入门

## 目标

1. 项目准备
2. 使用`pygame`创建图形窗口
3. 理解 **图像** 并实现图像绘制
4. 理解 **游戏循环** 和 **游戏时钟**
5. 理解 **精灵** 和 **精灵组**

## 项目准备

1. 新建 **飞机大战** 项目
2. 新建一个 cyw_01_pygame.py
3. 导入 **游戏素材图片**

**游戏的第一印象**

- 把一些 **禁止的图像** 绘制到 **游戏窗口** 中
- 根据 **用户的交互** 或其他情况，**移动** 这些图像，产生动画效果
- 根据 **图像之间** 是否发生重叠，判断 **敌机是否被摧毁** 等其他情况

## 01.使用 pygame 创建图像窗口

**小节目标**

1. 游戏的初始化和退出
2. 理解游戏中的坐标系
3. 创建游戏主窗口
4. 简单的游戏循环

*可以将图片素材 **绘制** 到 **游戏的窗口上**，开发游戏之前需要先知道 如何建立游戏窗口！*

### 1.1 游戏的初始化和退出

- 要使用`pygame`提供的所有功能之前，需要调用`int`方法
- 在游戏结束需要调用一下`quit`方法

| 方法            | 说明                                                         |
| --------------- | ------------------------------------------------------------ |
| pygame.int ( )  | 导入并初始化所有 pygame 模块，使用其他模块之前，必须先调用 init 方法 |
| pygame.quit ( ) | 卸载所有 pygame 模块，在游戏结束之前调用！                   |

![image-20210821153209250](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821153209250.png)

### 1.2 理解游戏中的坐标系

- **坐标系**
  1. **原点** 在 **左上角**`(0,0)`
  2. **x轴** 水平方向向 **右**，逐渐增加
  3. **y轴** 垂直方向向 **下**，逐渐增加

![image-20210821153833695](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821153833695.png)

- 在游戏中，**所有可见的元素** 都是以 **矩形区域** 来描述位置的

    要描述一个区域有四个要素：`(x, y) (width, height)`

- `pygame`**专门提供了一个类**`pygame.Rect`用于描述 **矩形区域**

```
Rect(x, y, widh, height) -> Rect
```

![image-20210821154524636](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821154524636.png)

**提示**

- `pygame.Rect`是一个比较特殊的类，内部只是封装了一些数字计算
- **不执行**`pygame.init()`方法同样能够直接使用

### 1.3创建游戏主窗口

- `pygame`专门提供了一个 **模块**`pygame.display`用于创建、管理 **游戏窗口**

![image-20210821160102092](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821160102092.png)

set_mode **方法**

```
set_mode(resolution=(0,0)),flags=0,flats=0, depth=0) -> Surface
```

- 作用 -- 创建游戏显示窗口

- 参数

  1. `resolution`指定屏幕的`宽`和`高`，默认创建的窗口大小和屏幕大小一致
  2. `flags`参数指定屏幕的附加选项
  3. `depth`参数表示颜色的位数，默认自动匹配

- **返回值**

  ​    **暂时** 可以理解为 **游戏的屏幕，游戏的元素** 都需要被绘制到 **游戏的屏幕** 上

- **注意：**必须使用变量记录`set_mode`方法的返回结果！因为：后续所有的图像绘制都基于这个返回结果

![image-20210821161823715](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821161823715.png)

### 1.4 简单的游戏循环

- 为了做到游戏程序启动后，**不会立即推出，**通常会在游戏程序中增加一个 **游戏循环**

- 所谓 **游戏循环** 就是一个 **无限循环**

- 在 **创建游戏窗口** 代码下方，增加一个无限循环

    注意：**游戏窗口不需要重复创建**

![image-20210821162857025](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821162857025.png)

## 02. 理解 图像 并实现图像绘制

- 在游戏中，能够看到的 **游戏元素** 大多是 **图像**

  ​    **图像文件** 初始是保存在磁盘上的，如果需要使用，**第一步** 就需要 被加载到内存

- 要在屏幕上 **看到某一个图像的内容，**需要按照三个步骤:

  1. 使用`pygame.image.load()`**加载图像的数据**
  2. 使用 **游戏屏幕** 对象，调用`blit`方法 将图像绘制到指定位置
  3. 调用`pygame.display.update()`方法更新整个屏幕的显示

![image-20210821163653113](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821163653113.png)

提示：要想在屏幕上看到绘制的结果，就一定要调用`pygame.display.update()`方法

#### 理解update( )方法的作用

*可以在`screen`对象完成 **所有`blit`**方法之后，**统一调用一次`display.update`**方法，同样可以在屏幕上 **看到最终的绘制结果***

- 使用`display.set_mode()`创建的`screen`**对象** 是一个 **内存中的屏幕数据对象**

    可以理解成是 **油画** 的 **画布**

- `screen.blit`方法可以在 **画布** 上绘制很多 **图像**

    **这些图像** 有可能 会彼此 **重叠或者覆盖**

- `display.update()`会将 **画布** 的 **最终结果** 绘制在屏幕上，这样可以 **提高屏幕绘制效率，增加游戏的流畅度**

## 03. 理解 游戏循环 和 游戏时钟

### 3.1 游戏中的动画实现原理

- 跟 **电影** 的原理类似，游戏中的动画效果，本质上是 **快速** 的在屏幕上绘制 **图像**

    电影是将多张 **静止的电影胶片 连续、快速**的播放，产生连贯的视觉效果！

- 一般在电脑上 **每秒绘制60次**,就能够达到非常 **连续 高品质** 的动画效果

    每次绘制的结果被称为 **帧 Frame**

### 3.2 游戏循环

**游戏的两个组成部分**

​    **游戏循环的开始** 就意味着 **游戏的正式开始**

![image-20210821182645444](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821182645444.png)

游戏循环的作用

1. 保证游戏 **不会直接推出**
2. **变化图像位置 --** 动画效果
   * 每隔`1 / 60 秒`移动一下所有图像的位置
   * 调用`pygame.display.update()`更新屏幕显示
3. **检测用户交互 --** 按键、鼠标等…

### 3.3 游戏时钟

- `pygame`专门提供了一个类`pygame.time.Clock`可以非常方便的设置屏幕绘制速度 -- **刷新帧率**
- 要使用 **时钟对象** 需要两步：
  1. 在 **游戏初始化** 创建一个 **时钟对象**
  2. 在 **游戏循环** 中让时钟对象调用`tick(帧率)`方法
- `tick`方法会根据 **上次被调用的时间，**自动设置 **游戏循环** 中的延时

### 3.4 英雄飞机的简单动画

**需求**

1. 在 **游戏初始化** 定义一个`pygame.Rect`的变量记录英雄的初始位置

2. 在 **英雄循环** 中每次让 **英雄** 的`y - 1`-- 向上移动

3. `y <= 0`将英雄移到屏幕的底部

   提示：

   - 每一次调用`update()`方法之前，需要把 **所有的游戏图像都重新绘制一遍**
   - 而且应该 **最先** 重新绘制 **背景图像**

![image-20210821192230243](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821192230243.png)

1. 英雄向上飞行，当 **英雄完全从上方飞出屏幕后**
2. 将飞机移动到屏幕的底部

![image-20210821192622651](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821192622651.png)

- `Rect`的属性`bottom = y + height`

![image-20210821192724300](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821192724300.png)

### 3.5 在游戏循环中 监听 事件

**事件 event**

- 就是游戏启动后，**用户针对游戏所做的操作**
- 例如：**点击关闭按钮，点击鼠标，按下键盘…**

监听

- 在 **游戏循环** 中，判断用户 **具体的操作**
- *只有 **捕获** 到用户具体的操作，才能有针对下的做出响应*

代码实现

- `pygame`中通过`pygame.event.get()`可以获得 **用户当前所作动作** 的 **事件列表**

    用户可以同一时间做很多事情

- 提示：**这段代码非常的固定**，几乎所有的`pygame`游戏都 **大同小异！**

![image-20210821194255016](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210821194255016.png)

## 04. 理解 精灵 和 精灵组

### 4.1 精灵 和 精灵组

- 在刚刚完成的案例中，**图像加载、位置变化、绘制图像** 都需要程序员编代码分别处理

- 为了简化开发步骤，`pygame`提供了两个类

    `pygame.sprite.Sprite`-- 存储 **图像数据 image** 和 **位置 rect** 的 **对象**
  
     `pygame.sprite.Group`       

![image-20210822033056119](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210822033056119.png)

### 4.2 派生精灵子类

1. 新建`plane_sprites.py`文件
2. 定义`GameSprite`继承自 `pygame.sprite.Sprite`

**注意**

- 如果一个类的 **父亲** 不是`object`
- 在重写 **初始化方法**时，**一定要** 先`super()`一下父亲的`__iinit__`方法
- **保证父亲中实现的**__ ___init___ __,代码能够被支持执行

![image-20210822034856937](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210822034856937.png)

**属性**

- `image`精灵图像，使用`image_name`加载
- `rect`精灵大小，默认使用图片大小
- `speed`精灵移动速度，默认为`1`

**方法**

- `update`每次更新屏幕时在游戏循环内调节

   让精灵的`self.rect.y += self.speed`

**提示**

- `image`和`get_rect()`方法，**可以返回 pygame,Rect(0, 0,图像宽，图像高)**的对象

### 4.3 使用 游戏精灵 和精灵组 创建敌机

**需求**

- 使用刚刚派生的 **游戏精灵** 和 **精灵组** 创建 敌机 并且实现敌机动画

**步骤**

1. 使用`from`导入`plane_sprites`模块
   - `from`导入的模块可以 **直接使用**
   - `import`导入的模块需要通过 **模块名.**来使用
2. 在 **游戏初始化** 创建 **精灵对象** 和 **精灵组对象**
3. 在 **游戏初循环中** 让 **精灵组** 分别调用`updata()`和`draw(screen)`方法

**职责**

- 精灵
  1. 封装 **图像 image、位置 rect** 和 **速度 speed**
  2. 提供`update()`方法，根据游戏需求，**更新位置rect**
- 精灵组
  1. 包含 **多个 精灵对象**
  2. `update`方法，让精灵组中的所有精灵调用`update`方法更新位置
  3. `draw(screen)`方法，在`screen`上绘制精灵组中的所有精灵

# 游戏框架搭建

## 目标

- 明确主程序职责
- 实现主程序类
- 准备游戏精灵组

## 01. 明确主程序职责

- 一个游戏主程序的 **职责** 可以分为两个部分：
  1. 游戏初始化
  2. 游戏循环
- 根据明确的职责，设计`PlaneGame`类如下：

![image-20210822130244518](C:\Users\CYW\AppData\Roaming\Typora\typora-user-images\image-20210822130244518.png)

***提示*** *根据 **职责** 封装私有方法，可以避免某一个方法的代码写得太长*

如果某一个方法编写的太长，既不好阅读，也不好维护

- **游戏初始化 --** `__init__()`会调用以下方法：
